---

**Θέμα 1 (40%)**

Εργάζεστε για την ανάπτυξη οδηγού συσκευής παρακολούθησης ασθενών σε νοσοκομεία. Το υλικό αποτελείται από ένα σύνολο αισθητήρων οι οποίοι τοποθετούνται στο σώμα των ασθενών και καταγράφουν στοιχεία, όπως θερμοκρασία σώματος, παλμούς, δείκτες αίματος κλπ. Τα δεδομένα αποστέλλονται σε σταθμό βάσης ο οποίος συνδέεται σε υπολογιστικό σύστημα με ΛΣ Linux. Το στρώμα συλλογής δεδομένων του οδηγού της συσκευής εκτελείται σε interrupt context και τοποθετεί τα δεδομένα σε δομή κυκλικού απομονωτή (circular buffer).

```c
struct medical_dev {
    ...locktype... lock;
    wait_queue_head_t wq;
    uint128_t cnt; /* This is initialized to zero and will never wrap. */

    #define CIRC_BUF_SIZE (1024 * sizeof(struct patient_data))
    char circ_buffer[CIRC_BUF_SIZE];
} medical_dev;
```

Τα στοιχεία κάθε μέτρησης αποθηκεύονται σε δομές τύπου `struct patient_data`, ενδεικτικού μεγέθους 64 bytes η κάθε μία. Δίνεται η συνάρτηση χειρισμού διακοπών:

```c
void intr(void)
{
    struct medical_dev *dev = &medical_dev;
    struct patient_data pd;

    get_patient_data_from_hw(&pd); /* Get data from the real device. */
    ... lock medical_dev ...
    memcpy(&dev->circ_buffer[dev->cnt % CIRC_BUF_SIZE], &pd,
           sizeof(struct patient_data));
    dev->cnt += sizeof(struct patient_data);
    ... unlock medical_dev ...
    wake_up_interruptible(&dev->wq);
}
```

Ο οδηγός υλοποιεί μία συσκευή χαρακτήρων `/dev/medical` και πρέπει να τηρεί τις παρακάτω προδιαγραφές:

1. Κάθε `read()` επιστρέφει bytes από το πολύ μία μέτρηση.
2. Διαδοχικές κλήσεις `read()` επιστρέφουν δεδομένα από χρονικά συνεχόμενες μετρήσεις που γράφτηκαν στον κυκλικό απομονωτή μόνο από τη στιγμή του `open()` και μετά, με τη σειρά που γράφτηκαν, ως ένα ρεύμα (stream) από bytes.
3. Αν για οποιοδήποτε λόγο δεν είναι δυνατή η ανάκτηση χρονικά συνεχόμενων μετρήσεων από δύο διαδοχικές `read()`, τότε η δεύτερη `read()` επιστρέφει EOF. Για την ανάκτηση νέου ρεύματος έγκυρων μετρήσεων πρέπει η διεργασία να κάνει `close()` και εκ νέου `open()`.
4. Όταν η διεργασία έχει διαβάσει πλήρως όλες τις διαθέσιμες μετρήσεις, κοιμάται μέχρι να εγγραφεί νέα μέτρηση στον κυκλικό απομονωτή από τη συνάρτηση χειρισμού διακοπών.

Δίνεται ο σκελετός του οδηγού. Θεωρείστε ότι οι κλήσεις για δέσμευση μνήμης καθώς και οι κλήσεις αντιγραφής μνήμης επιτυγχάνουν πάντα:

```c
struct chrdev_state {
    ...locktype... lock;
    struct medical_dev *medical_dev;

    char local_buf[sizeof(struct patient_data)];
    uint128_t local_cnt; /* Suppose it will never wrap. */
};

static int medical_chrdev_open(struct inode *inode, struct file *filp)
{
    struct chrdev_state *state;
    struct medical_dev *dev = &medical_dev;

    if (nonseekable_open(inode, filp) < 0)
        return -ENODEV;

    state = kmalloc(sizeof(struct chrdev_state), GFP_KERNEL);
    ... ??? ...
}
```
---

```c
static ssize_t medical_chrdev_read(struct file *filp, char __user *usrbuf,
                                   size_t cnt, loff_t *f_pos)
{
    struct chrdev_state *state;
    struct medical_dev *dev;

    state = filp->private_data;
    dev = state->medical_dev;

    ... ??? ...

    /* Do we need to fetch a fresh measurement? */
    if (*f_pos == 0) {
        ... ??? ...
    }

    ... ??? ...
}
```

**Ζητούνται τα εξής:**

i. (7%) Τι μετράει το πεδίο cnt της δομής `medical_dev`; Ποιος ο ρόλος των πεδίων lock και wq της ίδιας δομής; Τι τύπου είναι τα κλειδώματα των δομών `medical_dev` και `chrdev_state` και γιατί;

ii. (6%) Ποιος ο ρόλος της δομής `chrdev_state`; Εξηγήστε συνοπτικά τη χρησιμότητα των πεδίων `local_buf` και `local_cnt`. Πότε αρχικοποιείται το `local_cnt` και πότε αυξάνεται;

iii. (7%) Σε ποια περίπτωση δύο διαδοχικές `read()` δεν μπορούν να επιστρέψουν δεδομένα από χρονικά συνεχόμενες μετρήσεις, οπότε και η δεύτερη `read()` επιστρέφει EOF; Τι έχει συμβεί ανάμεσα στις κλήσεις των δύο `read()`;

iv. (20%) Υλοποιήστε τις `medical_chrdev_open()` και `medical_chrdev_read()` του οδηγού συσκευής. Εξηγήστε συνοπτικά πώς εξασφαλίζεται ότι ο οδηγός σας τηρεί τις τέσσερις προδιαγραφές που αναφέρονται παραπάνω.

---

**Θέμα 2 (35%)**

**α. (12%) Σωστό ή Λάθος: Αιτιολογήστε συνοπτικά την απάντησή σας.**

i. Στο σύστημα αρχείων ext2 το inode table καταλαμβάνει ένα ή και περισσότερα blocks του συστήματος αρχείων.

ii. Στο σύστημα αρχείων ext2 το inode bitmap ενός block group μπορεί να καταλαμβάνει περισσότερα του ενός block στο σύστημα αρχείων.

iii. Το Linux υποστηρίζει μόνο ένα συγκεκριμένο σύστημα αρχείων.

iv. Σε ένα σύστημα αρχείων ext2 ο συνολικός αριθμός inodes σε ένα σύστημα αρχείων καθορίζεται μόνο κατά τη δημιουργία του συστήματος αρχείων και δε μπορεί να αλλάξει αργότερα.

v. Στο σύστημα αρχείων ext2 υπάρχει ένα μοναδικό superblock σε συγκεκριμένο σημείο του δίσκου.

vi. Σε έναν δίσκο με σύστημα αρχείων ext2 το superblock αποθηκεύεται στην αρχή του δίσκου.

vii. Σε ένα σύστημα αρχείων ext2 ένα inode ενός αρχείου περιέχει και το όνομα του αρχείου.

viii. Σε ένα σύστημα αρχείων ext2 το μέγεθος ενός inode καθορίζεται μόνο κατά τη δημιουργία του συστήματος αρχείων και δε μπορεί να αλλάξει αργότερα.

---

**β. (23%) Απαντήστε συνοπτικά στις παρακάτω ερωτήσεις:**

i. Αναφέρατε δύο σημεία μέσα σε ένα σύστημα αρχείων ext2 από όπου μπορούμε να εξάγουμε την πληροφορία του πόσα inodes ενός ext2 συστήματος αρχείων είναι ελεύθερα.

ii. Τι είναι το superblock; Σε ποια θέση αποθηκεύεται σε ένα διαμέρισμα ενός δίσκου που περιέχει ένα ext2 σύστημα αρχείων; Αναφέρατε τρία πεδία του καθώς και τι αναπαριστά το καθένα από αυτά.

iii. Τι είναι το inode; Πόσα υπάρχουν σε ένα διαμέρισμα ενός δίσκου που περιέχει ένα ext2 σύστημα αρχείων; Σε ποιες θέσεις αποθηκεύονται μέσα στο δίσκο;

iv. Πόσα inodes χρειάζεται να προετοιμαστούν ώστε να βρεθούν τα περιεχόμενα του αρχείου `/dir1/dir2/file`;

v. Κάθε φορά που δημιουργείται ένας καινούριος φάκελος σε ένα ext2 σύστημα αρχείων στο inode που αναφέρεται ότι υπάρχουν δύο hard links. Γιατί γίνεται αυτό και ποια είναι τα δύο "ονόματα" που αναφέρονται σε αυτό το inode;

vi. Προσπαθείτε να δημιουργήσετε ένα νέο αρχείο σε ένα σύστημα αρχείων ext2 και λαμβάνετε μήνυμα σφάλματος ότι δεν υπάρχει διαθέσιμος χώρος στο δίσκο. Αναφέρετε δύο λόγους στους οποίους μπορεί να οφείλεται αυτό.

---

**Θέμα 3 (25%)**

**α. (5%) Σωστό ή Λάθος: Αιτιολογήστε συνοπτικά την απάντησή σας.**

i. Οι κλήσεις συστήματος εκτελούνται πάντα σε process context.

ii. Κώδικας που εκτελείται σε interrupt context επιτρέπεται να καλέσει την down_interruptible().

iii. Όταν χρησιμοποιούμε την κλήση συστήματος unlink() διαγράφονται πάντα τα περιεχόμενα του αρχείου που περνάμε ως παράμετρο.

iv. Η χρήση spinlocks σε χώρο πυρήνα επιτρέπεται μόνο για τον αμοιβαίο αποκλεισμό μεταξύ κομματιών κώδικα που εκτελούνται σε process context.

v. Οι σωληνώσεις που δημιουργούνται μέσω της κλήσης συστήματος pipe() μπορούν να χρησιμοποιηθούν μόνο μεταξύ γονικής διεργασίας και των παιδιών της.

---

**β. (10%) Εκτελέστε την ακόλουθη εντολή στο φλοιό του Linux:**

```bash
$ cat foo | grep bar > out 2>&1
```

Η παραπάνω εντολή ανακατευθύνει το output της cat στη grep και στη συνέχεια ανακατευθύνει το stdout και stderr της grep στο αρχείο out. Σκιαγραφήστε πώς υλοποιεί ο φλοιός τις δύο ανακατευθύνσεις. Ποιες κλήσεις συστήματος θα εκτελεστούν και με ποια σειρά; Πόσες διεργασίες θα δημιουργηθούν; Ποιος και με τι permissions ανοίγει τα αρχεία foo και out;

---

**γ. (10%) Δίνεται το παρακάτω πρόγραμμα:**

```c
1  int main (int argc, char *argv[]) {
2      char buf[1024];
3      int fd = open("./file", O_CREAT | O_RDWR | O_TRUNC, S_IRWXU);
4      memset(buf, 'd', 1024);
5      lseek(fd, 4096, SEEK_SET);
6      write(fd, &buf, 1024);
7      close(fd);
8  }
```

**Υποθέστε ότι το αρχείο `./file` αρχικά δεν υπάρχει.**

i. Τι κάνει το παραπάνω πρόγραμμα;

ii. Ξαναγράψτε το πρόγραμμα ώστε να μην είναι εφικτό κάποιος να δει τι γράφετε στο αρχείο με χρήση της `strace`.

---
