# Θέμα 1 (35%)

Σας ζητείται η ανάπτυξη οδηγού συσκευής χαρακτήρων (character device driver), για  
έναν επιταχυντή συμπίεσης δεδομένω (data compression accelerator). Η συσκευή  
προγραμματίζεται μέσω ενός πίνακα (array), ο οποίος έχει ένα συγκεκριμένο αριθμό  
από θέσεις (slots) για αιτήσεις (requests) προς την συσκευή και στον οποίο έχει  
πρόσβαση τόσο ο οδηγός όσο και η συσκευή.

Δίνονται οι παρακάτω δομές, για τις αιτήσεις και για τον πίνακα:

```c
typedef enum{
    DCA_REQ_FREE,
    DCA_REQ_RESERVED,
    DCA_REQ_FINISHED
} dca_status_t;
#define MAX_DATA_SZ (4<<20)
typedef struct{
    uint8_t input[MAX_DATA_SZ];
    uint8_t result[MAX_DATA_SZ];
    dca_status_t status;
    wait_queue_head_t request_wq;
} dca_request_t;
#define MAX_REQS (64*sizeof(dca_request_t))
typedef struct{
    ...locktype... lock;
    wait_queue_head_t slots_wq;
    dca_request_t reqs[MAX_REQS];
} dca_dev_t;
dca_dev_t dca_dev;
```

Υποθέστε ότι η συσκευή (`dca_dev`) και ο πίνακας με τα requests έχουν αρχικοποιηθεί  
με όλα τα requests να είναι ελεύθερα (`DCA_REQ_FREE`).

Επίσης, δίνονται οι παρακάτω συναρτήσεις για την διαχείριση του πίνακα και των  
αιτήσεων:

```c
void dca_req_set_status(dca_request_t *req, dca_status_t status){
    req->status = status;
}

dca_request_t *dca_find_free_req(dca_request_t *reqs){
    int i;
    for(i=0; i<MAX_REQS; i++){
        if (reqs[i]->status == DCA_REQ_FREE) return reqs[i];
    }
    return NULL;
}

dca_request_t *dca_is_req_finished(dca_request_t *req){
    return req->status == DCA_REQ_FINISHED;
}

// implemented elsewhere
void dca_notify_device(dca_request_t *req);
```

Για την υποβολή (submission) ενός request, ο οδηγός θα πρέπει:
1. Να δεσμεύει ένα slot από τον πίνακα αιτήσεων. Σε περίπτωση που όλα τα  
   requests χρησιμοποιούνται, θα πρέπει να υπάρχει δυνατότητα αναμονής και  
   ειδοποίησης μόλις ελευθερωθεί κάποιο request (μέσω του `slots_wq`). Ένα  
   request δεσμεύεται κάνοντας το status του `DCA_REQ_RESERVED` (καλώντας  
   την `dca_req_set_status()`).
2. Να κάνει copy τα δεδομένα εισόδου προς συμπίεση στο `input` buffer του request.
3. Να ειδοποιήσει την συσκευή ότι το συγκεκριμένο request είναι έτοιμο για  
   επεξεργασία από την συσκευή, καλώντας την `dca_notify_device()`.
4. Να περιμένει μέχρι την ολοκλήρωση του request, χρησιμοποιώντας το  
   `request_wq`.

Μόλις ολοκληρωθεί η συμπίεση των δεδομένων ενός request, η συσκευή αλλάζει το  
`status` του σε `DCA_REQ_FINISHED` και στη συνέχεια κάνει trigger ένα interrupt για να  
ειδοποιήσει τον οδηγό.

Για την ανάκτηση των αποτελεσμάτων ενός request, ο οδηγός θα πρέπει:
1. Να κάνει handle το interrupt της συσκευής, βρίσκοντας τα requests που έχουν  
   ολοκληρωθεί, δηλαδή τα requests με `status` `DCA_REQ_FINISHED` (μπορεί να  
   είναι >1).
2. Για κάθε ολοκληρωμένο request θα πρέπει να ειδοποιείται το αντίστοιχο request  
   waitqueue (`request_wq`), και στη συνέχεια να ανακτάται το αποτέλεσμα (τα  
   συμπιεσμένα δεδομένα) και να ελευθερώνεται το request (από  
   `DCA_REQ_FINISHED` το `status` πρέπει να γίνει `DCA_REQ_FREE`).

---

**3. Σε περίπτωση που υπάρχουν διεργασίες ή threads σε αναμονή για ελεύθερο request (στο slots_wa), ο οδηγός θα πρέπει να τους κάνει notify, ώστε να μπορέσουν να δοκιμάσουν ξανά να δεσμεύσουν ένα request.**

**Δίνεται ο σκελετός της συνάρτησης χειρισμού διακοπών:**

```c
void dca_dev_intr(void) {
    dca_dev_t *dev = &dca_dev;

    ... lock dev ...
    ...
    ... unlock dev ...
}
```

**Η διεπαφή χρήστη με την συσκευή υλοποιείται μέσω της κλήσης συστήματος ioctl().**
Ο χρήστης χρησιμοποιεί το ioctl command `DCA_SUBMIT_REQ`, με όρισμα μια δομή τύπου `dca_user_request_t`. Ο οδηγός επεξεργάζεται το request και επιστρέφει στο userspace μόλις αυτό ολοκληρωθεί, βάζοντας στο πεδίο result του `dca_user_request_t` τα compressed δεδομένα.

**Δίνεται ο σκελετός του οδηγού. Θεωρούμε πως οι κλήσεις για δέσμευση και αντιγραφή μνήμης επιτυγχάνουν πάντα:**

```c
static int dca_chrdev_open(struct inode *inode, struct file *filp) {
    int ret = 0;
    dca_dev_t *dev = &dca_dev;

    if ((ret = nonseekable_open(inode, filp)) < 0) {
        ret = -ENODEV;
        goto out;
    }

    filp->private_data = dev;
    return ret;

out:
    return ret;
}

typedef struct {
    uint8_t input[MAX_DATA_SZ];
    uint8_t result[MAX_DATA_SZ];
} dca_user_request_t;

#define DCA_MAGIC 'D'
#define DCA_SUBMIT_REQ _IORW(DCA_MAGIC, 0, dca_user_request_t);

static long dca_chrdev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
    dca_user_request_t __user *argp = (dca_user_request_t __user *)arg;
    dca_dev_t *dev = filp->private_data;

    switch (cmd) {
        case DCA_SUBMIT_REQ:
            ...
            break;

        default:
            return -EINVAL;
    }

    return 0;
}
```

Ζητούνται τα εξής:
i. (15%) Συμπληρώστε την υλοποίηση της dca_chrdev_ioctl() του οδηγού συσκευής.
ii. (10%) Συμπληρώστε την υλοποίηση του interrupt handler dca_dev_intr().
iii. (5%) Τι τύπου είναι το πεδίο lock της δομής dca_dev_t; Αιτιολογήστε την απάντησή σας.
    Περιγράψτε συνοπτικά σε ποιες περιπτώσεις χρειάζεται αμοιβαίος αποκλεισμός και μεταξύ
    ποιων. Πως το εξασφαλίσατε στον κώδικά σας;
iv. (5%) Δώστε ένα παράδειγμα userspace προγράμματος που χρησιμοποιεί την συσκευή.
    Υποθέστε ότι η συσκευή γίνεται expose στο userspace μέσω του /dev/dca.

---

Θέμα 2 (35%)

α) Σωστό ή Λάθος; Αιτιολογήστε συνοπτικά την απάντησή σας.
i. Σε κάθε σύστημα αρχείων ext2 υπάρχει ένα μοναδικό superblock σε συγκεκριμένο σημείο
   του δίσκου
ii. Η θέση του superblock σε έναν δίσκο με ext2 σύστημα αρχείων εξαρτάται από το μέγεθος
   που έχει το block για αυτό το σύστημα αρχείων
iii. Ο συνολικός αριθμός inodes σε ένα σύστημα αρχείων καθορίζεται μόνο κατά τη δημιουργία
   του συστήματος αρχείων και δεν μπορεί να αλλάξει αργότερα.
iv. Το Linux υποστηρίζει μόνο ένα συγκεκριμένο σύστημα αρχείων.
v. Μέσα στο inode ενός αρχείου αποθηκεύεται και το όνομα του αρχείου.
vi. Το inode bitmap καταλαμβάνει πάντα ένα μόνο block στο σύστημα αρχείων.
vii. Το inode table καταλαμβάνει πάντα ένα μόνο block στο σύστημα αρχείων.
viii. Το μέγεθος ενός inode καθορίζεται μόνο κατά την δημιουργία του συστήματος αρχείων.

β) Απαντήστε συνοπτικά στις παρακάτω ερωτήσεις:
i. Τι είναι το superblock; Σε ποια θέση αποθηκεύεται σε ένα διαμέρισμα ενός δίσκου που
   περιέχει ένα ext2 σύστημα αρχείων; Αναφέρατε τρία πεδία του καθώς και τι αναπαριστά το
   καθένα από αυτά.
ii. Τι είναι το inode; Πόσα υπάρχουν σε ένα διαμέρισμα ενός δίσκου που περιέχει ένα ext2
    σύστημα αρχείων; Σε ποιες θέσεις αποθηκεύονται μέσα στον δίσκο;
iii. Αναφέρατε δύο τρόπους για να εξάγουμε την πληροφορία του πόσα inodes ενός ext2
     συστήματος αρχείων είναι ελεύθερα.
iv. Προσπαθείτε να δημιουργήσετε ένα νέο αρχείο σε ένα σύστημα αρχείων ext2 και λαμβάνετε
    μήνυμα σφάλματος ότι δεν υπάρχει διαθέσιμος χώρος στο δίσκο. Αναφέρατε δύο λόγους
    στους οποίους μπορεί να οφείλεται αυτό.
v. Πόσα inodes χρειάζεται να προσπελαστούν ώστε να βρεθούν τα περιεχόμενα του αρχείου
   /dir1/dir2/file;
vi. Κάθε φορά που δημιουργείται ένας καινούριος φάκελος σε ένα ext2 σύστημα αρχείων στο
    inode του αναφέρεται ότι υπάρχουν δύο hard links. Γιατί γίνεται αυτό και ποια είναι τα δύο
    “ονόματα” που αναφέρονται σε αυτό το inode.

---

**Θέμα 3 (30%)**

**α. (7%) Σωστό ή Λάθος: Αιτιολογήστε συνοπτικά την απάντησή σας.**

i. Όταν χρησιμοποιούμε την κλήση συστήματος unlink() διαγράφονται πάντα τα περιεχόμενα του αρχείου που περνάμε ως παράμετρο.

ii. Για το κλείδωμα κοινόχρηστων δομών που προσεγγίζονται και από κώδικα κάποιου interrupt handler χρησιμοποιούμε αποκλειστικά spinlocks.

iii. Μπορούμε πάντα να δούμε με την strace τις εγγραφές που πραγματοποιούνται από μία διεργασία σε ένα ανοιχτό αρχείο, ανεξαρτήτως της διεπαφής που χρησιμοποιήθηκε για την προσπέλαση του.

iv. Δύο kernel threads που διαβάζουν ταυτόχρονα από την ίδια εικονική διεύθυνση χώρου πυρήνα (e.g. 0xffffab0e) μπορεί να διαβάσουν διαφορετικά δεδομένα.

v. Ένας file descriptor συνδέεται πάντα με κάποιο αρχείο σε φυσική αποθηκεύση.

---

**β. (5%)** Δύο διεργασίες έχουν ανοίξει το ίδιο αρχείο foo.txt καλώντας η κάθε μία την open(). Η διεργασία A χρησιμοποιεί την lseek() για να επεξεργαστεί τα τελευταία 1024 bytes του αρχείου. Η διεργασία B στη συνέχεια καλεί την read(). Από ποιο σημείο του αρχείου θα ξεκινήσει να διαβάζει η διεργασία B; Σε ποια δομή του ΛΣ αποθηκεύεται το file offset και πότε μπορεί να το μοιράζονται δύο διεργασίες;

---

**γ. (8%)** Στο φλοιό Linux εκτελείτε την παρακάτω εντολή: 

```bash
echo "bar" | cat > foo.txt
```

Τι κάνει και ποια system calls θα κληθούν κατά την εκτέλεση της και με ποια σειρά; Ποια διεργασία και με τι permissions ανοίγει το αρχείο foo.txt;

---

**δ. (10%) Δίνεται το παρακάτω πρόγραμμα:**

```c
1  void main(void) {
2      int fd, i;
3      pid_t p;
4      char buf[4096];
5      unsigned long long sum;

6      fd = open("foo.txt", O_CREAT | O_RDWR);
7      p = fork();

9      if (p == 0) {
10         read(fd, buf, 4096);
11         for (i = 0; i < 4096; i++)
12             sum += buf[i];
13         write(fd, &sum, 8);
14     } else {
15         read(fd, buf, 4096);
16         for (i = 0; i < 4096; i++)
17             buf[i]++;
18         write(fd, buf, 4096);
19     }
20 }
```
