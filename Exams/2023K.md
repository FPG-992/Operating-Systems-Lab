# Θέμα 1 (35%)

Σας ζητείται η ανάπτυξη οδηγού συσκευής χαρακτήρων (character device driver), για  
έναν επιταχυντή συμπίεσης δεδομένω (data compression accelerator). Η συσκευή  
προγραμματίζεται μέσω ενός πίνακα (array), ο οποίος έχει ένα συγκεκριμένο αριθμό  
από θέσεις (slots) για αιτήσεις (requests) προς την συσκευή και στον οποίο έχει  
πρόσβαση τόσο ο οδηγός όσο και η συσκευή.

Δίνονται οι παρακάτω δομές, για τις αιτήσεις και για τον πίνακα:

```c
typedef enum{
    DCA_REQ_FREE,
    DCA_REQ_RESERVED,
    DCA_REQ_FINISHED
} dca_status_t;
#define MAX_DATA_SZ (4<<20)
typedef struct{
    uint8_t input[MAX_DATA_SZ];
    uint8_t result[MAX_DATA_SZ];
    dca_status_t status;
    wait_queue_head_t request_wq;
} dca_request_t;
#define MAX_REQS (64*sizeof(dca_request_t))
typedef struct{
    ...locktype... lock;
    wait_queue_head_t slots_wq;
    dca_request_t reqs[MAX_REQS];
} dca_dev_t;
dca_dev_t dca_dev;
```

Υποθέστε ότι η συσκευή (`dca_dev`) και ο πίνακας με τα requests έχουν αρχικοποιηθεί  
με όλα τα requests να είναι ελεύθερα (`DCA_REQ_FREE`).

Επίσης, δίνονται οι παρακάτω συναρτήσεις για την διαχείριση του πίνακα και των  
αιτήσεων:

```c
void dca_req_set_status(dca_request_t *req, dca_status_t status){
    req->status = status;
}

dca_request_t *dca_find_free_req(dca_request_t *reqs){
    int i;
    for(i=0; i<MAX_REQS; i++){
        if (reqs[i]->status == DCA_REQ_FREE) return reqs[i];
    }
    return NULL;
}

dca_request_t *dca_is_req_finished(dca_request_t *req){
    return req->status == DCA_REQ_FINISHED;
}

// implemented elsewhere
void dca_notify_device(dca_request_t *req);
```

Για την υποβολή (submission) ενός request, ο οδηγός θα πρέπει:
1. Να δεσμεύει ένα slot από τον πίνακα αιτήσεων. Σε περίπτωση που όλα τα  
   requests χρησιμοποιούνται, θα πρέπει να υπάρχει δυνατότητα αναμονής και  
   ειδοποίησης μόλις ελευθερωθεί κάποιο request (μέσω του `slots_wq`). Ένα  
   request δεσμεύεται κάνοντας το status του `DCA_REQ_RESERVED` (καλώντας  
   την `dca_req_set_status()`).
2. Να κάνει copy τα δεδομένα εισόδου προς συμπίεση στο `input` buffer του request.
3. Να ειδοποιήσει την συσκευή ότι το συγκεκριμένο request είναι έτοιμο για  
   επεξεργασία από την συσκευή, καλώντας την `dca_notify_device()`.
4. Να περιμένει μέχρι την ολοκλήρωση του request, χρησιμοποιώντας το  
   `request_wq`.

Μόλις ολοκληρωθεί η συμπίεση των δεδομένων ενός request, η συσκευή αλλάζει το  
`status` του σε `DCA_REQ_FINISHED` και στη συνέχεια κάνει trigger ένα interrupt για να  
ειδοποιήσει τον οδηγό.

Για την ανάκτηση των αποτελεσμάτων ενός request, ο οδηγός θα πρέπει:
1. Να κάνει handle το interrupt της συσκευής, βρίσκοντας τα requests που έχουν  
   ολοκληρωθεί, δηλαδή τα requests με `status` `DCA_REQ_FINISHED` (μπορεί να  
   είναι >1).
2. Για κάθε ολοκληρωμένο request θα πρέπει να ειδοποιείται το αντίστοιχο request  
   waitqueue (`request_wq`), και στη συνέχεια να ανακτάται το αποτέλεσμα (τα  
   συμπιεσμένα δεδομένα) και να ελευθερώνεται το request (από  
   `DCA_REQ_FINISHED` το `status` πρέπει να γίνει `DCA_REQ_FREE`).

---

**3. Σε περίπτωση που υπάρχουν διεργασίες ή threads σε αναμονή για ελεύθερο request (στο slots_wa), ο οδηγός θα πρέπει να τους κάνει notify, ώστε να μπορέσουν να δοκιμάσουν ξανά να δεσμεύσουν ένα request.**

**Δίνεται ο σκελετός της συνάρτησης χειρισμού διακοπών:**

```c
void dca_dev_intr(void) {
    dca_dev_t *dev = &dca_dev;

    ... lock dev ...
    ...
    ... unlock dev ...
}
```

**Η διεπαφή χρήστη με την συσκευή υλοποιείται μέσω της κλήσης συστήματος ioctl().**
Ο χρήστης χρησιμοποιεί το ioctl command `DCA_SUBMIT_REQ`, με όρισμα μια δομή τύπου `dca_user_request_t`. Ο οδηγός επεξεργάζεται το request και επιστρέφει στο userspace μόλις αυτό ολοκληρωθεί, βάζοντας στο πεδίο result του `dca_user_request_t` τα compressed δεδομένα.

**Δίνεται ο σκελετός του οδηγού. Θεωρούμε πως οι κλήσεις για δέσμευση και αντιγραφή μνήμης επιτυγχάνουν πάντα:**

```c
static int dca_chrdev_open(struct inode *inode, struct file *filp) {
    int ret = 0;
    dca_dev_t *dev = &dca_dev;

    if ((ret = nonseekable_open(inode, filp)) < 0) {
        ret = -ENODEV;
        goto out;
    }

    filp->private_data = dev;
    return ret;

out:
    return ret;
}

typedef struct {
    uint8_t input[MAX_DATA_SZ];
    uint8_t result[MAX_DATA_SZ];
} dca_user_request_t;

#define DCA_MAGIC 'D'
#define DCA_SUBMIT_REQ _IORW(DCA_MAGIC, 0, dca_user_request_t);

static long dca_chrdev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
    dca_user_request_t __user *argp = (dca_user_request_t __user *)arg;
    dca_dev_t *dev = filp->private_data;

    switch (cmd) {
        case DCA_SUBMIT_REQ:
            ...
            break;

        default:
            return -EINVAL;
    }

    return 0;
}
```

Ζητούνται τα εξής:
i. (15%) Συμπληρώστε την υλοποίηση της dca_chrdev_ioctl() του οδηγού συσκευής.

---

## (i) Υλοποίηση της συνάρτησης dca_chrdev_ioctl()

Η διαδικασία που πρέπει να ακολουθηθεί από το ioctl() για την υποβολή ενός request είναι η εξής:

1. **Δέσμευση ενός slot (request) από τον πίνακα:**
   - Καλούμε, μέσα σε προστατευμένη περιοχή (με χρήση του lock του dca_dev), τη συνάρτηση `dca_find_free_req()` για να βρούμε ένα request με status `DCA_REQ_FREE`.
   - Αν δεν βρεθεί, τότε περιμένουμε (wait) στο waitqueue `slots_wq` μέχρι κάποιος slot να ελευθερωθεί.
   - Μόλις βρεθεί, αλλάζουμε το status σε `DCA_REQ_RESERVED` μέσω της `dca_req_set_status()`.

2. **Copy των δεδομένων εισόδου από το userspace στο πεδίο input του request.**

3. **Ειδοποίηση της συσκευής:**  
   - Καλούμε την `dca_notify_device(req)` για να ειδοποιήσουμε ότι το request είναι έτοιμο για επεξεργασία.

4. **Αναμονή για ολοκλήρωση:**  
   - Περιμένουμε στο waitqueue του request (`request_wq`) μέχρι το status αλλάξει σε `DCA_REQ_FINISHED` (δηλαδή, η συνάρτηση που ελέγχει το finished request επιστρέφει true).

5. **Ανάκτηση αποτελεσμάτων και απελευθέρωση του slot:**
   - Κάνουμε copy του περιεχομένου του πεδίου `result` στο πεδίο result του δομής που παρέχεται από το userspace (τύπου `dca_user_request_t`).
   - Μετά, μέσα σε προστατευμένη περιοχή, αλλάζουμε το status από `DCA_REQ_FINISHED` σε `DCA_REQ_FREE` και ειδοποιούμε (wake up) διεργασίες που περιμένουν σε `slots_wq`.

Η παρακάτω υλοποίηση χρησιμοποιεί spinlocks (λόγω ανάμειξης process και interrupt context) για συγχρονισμό:

```c
static long dca_chrdev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
    dca_user_request_t __user *argp = (dca_user_request_t __user *)arg;
    dca_dev_t *dev = filp->private_data;
    dca_request_t *req;
    dca_user_request_t req_copy;
    long ret = 0;

    switch (cmd) {
        case DCA_SUBMIT_REQ:
            /* Αντιγραφή των δεδομένων εισόδου από το userspace σε τοπική μεταβλητή */
            if (copy_from_user(&req_copy, argp, sizeof(req_copy)) != 0)
                return -EFAULT;

            /* Κλείδωμα του dca_dev */
            spin_lock(&dev->lock);

            /* Βρίσκουμε ένα free request */
            req = dca_find_free_req(dev->reqs);
            while (!req) {
                /* Αν δεν υπάρχει ελεύθερο slot, περιμένουμε στο slots_wq */
                spin_unlock(&dev->lock);
                if (wait_event_interruptible(dev->slots_wq, 
                     (req = dca_find_free_req(dev->reqs)) != NULL))
                    return -ERESTARTSYS;
                spin_lock(&dev->lock);
            }

            /* Δεσμεύουμε το request */
            dca_req_set_status(req, DCA_REQ_RESERVED);

            /* Αποδεσμεύουμε το lock πριν κάνουμε copy δεδομένων προς το request */
            spin_unlock(&dev->lock);

            /* Αντιγραφή των εισόδων στο πεδίο input του request */
            memcpy(req->input, req_copy.input, MAX_DATA_SZ);

            /* Ειδοποίηση της συσκευής ότι το request είναι έτοιμο */
            dca_notify_device(req);

            /* Περιμένουμε στο request waitqueue μέχρι η συσκευή να ολοκληρώσει την επεξεργασία */
            if (wait_event_interruptible(req->request_wq, dca_is_req_finished(req))) {
                ret = -ERESTARTSYS;
                goto out;
            }

            /* Αντιγραφή του αποτελέσματος στο δοσμένο userspace structure */
            memcpy(req_copy.result, req->result, MAX_DATA_SZ);

            /* Απελευθερώνουμε το request: αλλάζουμε status σε DCA_REQ_FREE */
            spin_lock(&dev->lock);
            dca_req_set_status(req, DCA_REQ_FREE);
            spin_unlock(&dev->lock);

            /* Ξυπνάμε διεργασίες που περιμένουν ελεύθερο slot */
            wake_up_interruptible(&dev->slots_wq);

            /* Επιστρέφουμε το αποτέλεσμα στο userspace */
            if (copy_to_user(argp, &req_copy, sizeof(req_copy)) != 0)
                ret = -EFAULT;
            break;

        default:
            ret = -EINVAL;
    }
out:
    return ret;
}
```

**Σημειώσεις:**

- Χρησιμοποιούμε **spin_lock()/spin_unlock()** στο dev->lock ώστε να προστατεύουμε τις κοινές μεταβλητές (όπως το request table και τα status).
- Η αναμονή για ελεύθερο request γίνεται στο `slots_wq`. Αν δεν υπάρχει διαθέσιμο slot, αποδεσμεύουμε το lock και περιμένουμε.
- Για την αναμονή του συγκεκριμένου request, περιμένουμε στο waitqueue `req->request_wq` μέχρι το `dca_is_req_finished(req)` να επιστρέψει true.
- Μετά την ολοκλήρωση, αντιγράφουμε το αποτέλεσμα στο userspace και απελευθερώνουμε το slot (δηλαδή, το status τίθεται πάλι σε DCA_REQ_FREE).

---


ii. (10%) Συμπληρώστε την υλοποίηση του interrupt handler dca_dev_intr().

## (ii) Υλοποίηση του interrupt handler dca_dev_intr()

Ο interrupt handler καλείται όταν η συσκευή ολοκληρώνει επεξεργασία κάποιου request (δηλαδή, έχει αλλάξει το status του σε DCA_REQ_FINISHED) και θέλει να ειδοποιήσει τον οδηγό. Σε αυτή τη συνάρτηση πρέπει:

1. Να κλειδώνουμε το dca_dev->lock.
2. Να διατρέχουμε τον πίνακα των requests και για κάθε request που έχει status DCA_REQ_FINISHED:
   - Να καλούμε wake_up_interruptible() στο request waitqueue (`req->request_wq`), ώστε να ξυπνήσουν τυχόν διεργασίες που περιμένουν την ολοκλήρωση.
3. Επίσης, αν υπάρχουν διεργασίες που περιμένουν σε `slots_wq` (για ελεύθερο slot), να τα ξυπνήσουμε.
4. Να απελευθερώνουμε το lock.

Η υλοποίηση έχει ως εξής:

```c
void dca_dev_intr(void) {
    dca_dev_t *dev = &dca_dev;
    int i;

    /* Κλείδωμα της δομής dca_dev */
    spin_lock(&dev->lock);

    /* Διατρέχουμε τον πίνακα των requests */
    for (i = 0; i < MAX_REQS; i++) {
        dca_request_t *req = &dev->reqs[i];
        /* Αν το request έχει ολοκληρωθεί (status == DCA_REQ_FINISHED) */
        if (req->status == DCA_REQ_FINISHED) {
            /* Ξυπνάμε διεργασίες που περιμένουν στο request waitqueue */
            wake_up_interruptible(&req->request_wq);
        }
    }

    /* Ξυπνάμε διεργασίες που περιμένουν για ελεύθερο slot */
    wake_up_interruptible(&dev->slots_wq);

    spin_unlock(&dev->lock);
}
```

---

iii. (5%) Τι τύπου είναι το πεδίο lock της δομής dca_dev_t; Αιτιολογήστε την απάντησή σας.
    Περιγράψτε συνοπτικά σε ποιες περιπτώσεις χρειάζεται αμοιβαίος αποκλεισμός και μεταξύ
    ποιων. Πως το εξασφαλίσατε στον κώδικά σας;
## (iii) Τύπος πεδίου lock και αιτιολόγηση

Το πεδίο `lock` της δομής `dca_dev_t` είναι **spinlock_t**.  
**Αιτιολόγηση:**
- Ο οδηγός και ο interrupt handler έχουν ταυτόχρονη πρόσβαση στα δεδομένα της συσκευής (ειδικά στον πίνακα requests, τα status, και τα waitqueues).
- Η χρήση του spinlock είναι απαραίτητη επειδή οι λειτουργίες που γίνονται στον interrupt handler πρέπει να είναι non-sleepable (δεν επιτρέπεται να χρησιμοποιήσουμε mutex σε περιβάλλον interrupt).
- Έτσι, ο αμοιβαίος αποκλεισμός είναι αναγκαίος μεταξύ των διεργασιακών κλήσεων (π.χ. ioctl) και του interrupt handler, ώστε να μην προκύψουν race conditions στην ενημέρωση και ανάγνωση των shared μεταβλητών.

Στον κώδικά μας, χρησιμοποιούμε spin_lock()/spin_unlock() γύρω από κάθε κρίσιμη ενότητα που διαβάζει ή γράφει στα κοινά δεδομένα του dca_dev.

---

iv. (5%) Δώστε ένα παράδειγμα userspace προγράμματος που χρησιμοποιεί την συσκευή.
    Υποθέστε ότι η συσκευή γίνεται expose στο userspace μέσω του /dev/dca.


## (iv) Παράδειγμα userspace προγράμματος

Παρακάτω δίνεται ένα παράδειγμα userspace προγράμματος που χρησιμοποιεί το device `/dev/dca`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>

#define MAX_DATA_SZ (4<<20)

typedef struct {
    uint8_t input[MAX_DATA_SZ];
    uint8_t result[MAX_DATA_SZ];
} dca_user_request_t;

#define DCA_MAGIC 'D'
#define DCA_SUBMIT_REQ _IORW(DCA_MAGIC, 0, dca_user_request_t)

int main(void) {
    int fd;
    dca_user_request_t req;
    int ret;

    /* Ανοίγουμε τη συσκευή */
    fd = open("/dev/dca", O_RDWR);
    if (fd < 0) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    /* Ετοιμάζουμε την αίτηση: γεμίζουμε το input με κάποια δεδομένα */
    memset(req.input, 'A', MAX_DATA_SZ);  // για παράδειγμα, γεμίζουμε με 'A'
    memset(req.result, 0, MAX_DATA_SZ);

    /* Καλούμε ioctl για να υποβάλουμε το request και να περιμένουμε την ολοκλήρωση */
    ret = ioctl(fd, DCA_SUBMIT_REQ, &req);
    if (ret < 0) {
        perror("ioctl");
        close(fd);
        exit(EXIT_FAILURE);
    }

    /* Εμφανίζουμε το αποτέλεσμα (π.χ. πρώτα 100 bytes) */
    printf("Compressed result (first 100 bytes):\n");
    fwrite(req.result, 1, 100, stdout);
    printf("\n");

    close(fd);
    return 0;
}
```

**Επεξήγηση:**
- Το πρόγραμμα ανοίγει το `/dev/dca`.
- Δημιουργεί και αρχικοποιεί μια δομή `dca_user_request_t` με δεδομένα εισόδου.
- Καλεί το ioctl με το command `DCA_SUBMIT_REQ` και το &req ως παράμετρο.
- Μετά την ολοκλήρωση του request, το αποτέλεσμα (τα compressed δεδομένα) μεταφέρεται στο πεδίο result της δομής.
- Τέλος, εμφανίζει (ή επεξεργάζεται) το αποτέλεσμα και κλείνει τη συσκευή.

---

## Συνοψίζοντας

- **(i) dca_chrdev_ioctl():** Υλοποιεί τη δέσμευση ενός request slot, αντιγραφή εισόδου, ειδοποίηση της συσκευής, αναμονή ολοκλήρωσης και αντιγραφή αποτελέσματος στο userspace, με χρήση spinlocks και waitqueues.
- **(ii) dca_dev_intr():** Σε περίπτωση interrupt, διατρέχει τα requests και ξυπνά διεργασίες που περιμένουν στο request waitqueue, και ενημερώνει διεργασίες που περιμένουν ελεύθερα slots.
- **(iii) Το πεδίο lock είναι τύπου spinlock_t**, καθώς προστατεύει κοινά δεδομένα μεταξύ διεργασιακού και interrupt context.
- **(iv) Παράδειγμα userspace προγράμματος:** Δίνεται ο κώδικας που ανοίγει το device `/dev/dca`, υποβάλλει ένα request μέσω ioctl και λαμβάνει τα αποτελέσματα.

Θέμα 2 (35%)

α) Σωστό ή Λάθος; Αιτιολογήστε συνοπτικά την απάντησή σας.
i. Σε κάθε σύστημα αρχείων ext2 υπάρχει ένα μοναδικό superblock σε συγκεκριμένο σημείο
   του δίσκου

Λάθος. Σε κάθε σύστημα αρχείων ext2 υπάρχει ένα κύριο superblock και εφεδρικά αντίγραφα αυτού. Τα εφεδρικά αντίγραφα υπάρχουν για να διασφαλίζεται η ακεραιότητα του συστήματος αρχείων σε περίπτωση βλάβης του κύριου superblock. Τα εφεδρικά αντίγραφα του superblock αποθηκεύονται σε συγκεκριμένα blocks.

ii. Η θέση του superblock σε έναν δίσκο με ext2 σύστημα αρχείων εξαρτάται από το μέγεθος
   που έχει το block για αυτό το σύστημα αρχείων

Λάθος. Η θέση του superblock σε ένα σύστημα αρχείων ext2 είναι συγκεκριμένη και δεν εξαρτάται από το μέγεθος του block. Το superblock βρίσκεται πάντα στο ίδιο block, συνήθως στο πρώτο block μετά το boot sector, δηλαδή στο block #1. Τα επόμενα block groups έχουν επίσης εφεδρικά αντίγραφα του superblock, αλλά η θέση του αρχικού superblock δεν εξαρτάται από το μέγεθος του block.

iii. Ο συνολικός αριθμός inodes σε ένα σύστημα αρχείων καθορίζεται μόνο κατά τη δημιουργία
   του συστήματος αρχείων και δεν μπορεί να αλλάξει αργότερα.

Σωστό. Ο συνολικός αριθμός των inodes σε ένα σύστημα αρχείων ext2 καθορίζεται κατά τη δημιουργία του συστήματος αρχείων και δεν μπορεί να αλλάξει αργότερα. Ο αριθμός αυτός εξαρτάται από το μέγεθος του συστήματος αρχείων και το μέγεθος του inode.

Κατά το mkfs/ext2 ο συνολικός αριθμός inodes ορίζεται (π.χ. μέσω του πεδίου s_inodes_count στο superblock) και παραμένει σταθερός για τη ζωή του file system, εκτός αν γίνει επαναδημιουργία του.

iv. Το Linux υποστηρίζει μόνο ένα συγκεκριμένο σύστημα αρχείων.

Λάθος. Το Linux υποστηρίζει πολλαπλά συστήματα αρχείων. Υποστηρίζει συστήματα αρχείων για συσκευές μόνιμης αποθήκευσης (π.χ. ext2, ext3, ext4, NTFS, FAT), δικτυακά συστήματα αρχείων (π.χ. NFS, sshfs, CIFS), και ειδικά συστήματα αρχείων (π.χ. procfs, devtmpfs). Η δυνατότητα προσθήκης νέων συστημάτων αρχείων στον πυρήνα είναι δυναμική, μέσω modules.

v. Μέσα στο inode ενός αρχείου αποθηκεύεται και το όνομα του αρχείου.

Λάθος. Το όνομα του αρχείου δεν αποθηκεύεται στο inode. Το inode περιέχει μεταδεδομένα σχετικά με το αρχείο, όπως το μέγεθος, τα δικαιώματα πρόσβασης και τη θέση των data blocks. Η σύνδεση μεταξύ του ονόματος του αρχείου και του inode γίνεται μέσω των directory entries, οι οποίοι αποθηκεύονται σε blocks καταλόγων

vi. Το inode bitmap καταλαμβάνει πάντα ένα μόνο block στο σύστημα αρχείων.

Σωστό. Το inode bitmap καταλαμβάνει ένα block ανά block group. Το κάθε bit του bitmap αντιστοιχεί σε ένα inode, υποδεικνύοντας αν είναι ελεύθερο ή χρησιμοποιημένο

vii. Το inode table καταλαμβάνει πάντα ένα μόνο block στο σύστημα αρχείων.

Λάθος. To inode table δεν καταλαμβάνει πάντα ένα μόνο block. Το μέγεθος του inode table εξαρτάται από το μέγεθος του inode και το μέγεθος του block και συνεπώς καταλαμβάνει αρκετά blocks. Κάθε inode table περιέχει μια σειρά από inodes, και ο αριθμός των inodes που χωράει σε ένα inode table εξαρτάται από το μέγεθος του inode.


viii. Το μέγεθος ενός inode καθορίζεται μόνο κατά την δημιουργία του συστήματος αρχείων.

Σωστό. Το μέγεθος ενός inode καθορίζεται κατά τη δημιουργία του συστήματος αρχείων. Στις παλαιότερες εκδόσεις του ext2, το μέγεθος ήταν 128 bytes, αλλά στις νεότερες εκδόσεις, το μέγεθος του inode μπορεί να είναι διαφορετικό.

β) Απαντήστε συνοπτικά στις παρακάτω ερωτήσεις:
i. Τι είναι το superblock; Σε ποια θέση αποθηκεύεται σε ένα διαμέρισμα ενός δίσκου που
   περιέχει ένα ext2 σύστημα αρχείων; Αναφέρατε τρία πεδία του καθώς και τι αναπαριστά το
   καθένα από αυτά.

Το superblock είναι μια δομή δεδομένων που αποθηκεύει μεταδεδομένα σχετικά με το σύστημα αρχείων. Περιέχει πληροφορίες όπως ο συνολικός αριθμός των inodes και των blocks, ο αριθμός των διαθέσιμων inodes και blocks, το μέγεθος του block, κ.α.

Θέση αποθήκευσης: Το superblock αποθηκεύεται στην αρχή του διαμερίσματος, συνήθως στο πρώτο block μετά το boot sector (block #1). Επιπλέον, εφεδρικά αντίγραφα του superblock υπάρχουν και σε άλλα block groups.

Τρία πεδία και τι αναπαριστούν:
Συνολικός αριθμός inodes: Ο συνολικός αριθμός των inodes που υπάρχουν στο σύστημα αρχείων.
Συνολικός αριθμός blocks: Ο συνολικός αριθμός των blocks που υπάρχουν στο σύστημα αρχείων.
Μέγεθος block: Το μέγεθος των blocks που χρησιμοποιεί το σύστημα αρχείων (π.χ., 1KB, 2KB, 4KB).

ii. Τι είναι το inode; Πόσα υπάρχουν σε ένα διαμέρισμα ενός δίσκου που περιέχει ένα ext2
    σύστημα αρχείων; Σε ποιες θέσεις αποθηκεύονται μέσα στον δίσκο;

Τι είναι το inode; Το inode είναι μια δομή δεδομένων που αποθηκεύει μεταδεδομένα σχετικά με κάθε αρχείο, κατάλογο ή ειδικό αρχείο του συστήματος αρχείων. Δεν αποθηκεύει το όνομα του αρχείου, αλλά πληροφορίες όπως το μέγεθος, ο τύπος, τα δικαιώματα πρόσβασης, ο ιδιοκτήτης, η ομάδα, οι χρονοσφραγίδες, και οι θέσεις των data blocks του αρχείου.

Πόσα υπάρχουν: Ο αριθμός των inodes καθορίζεται κατά τη δημιουργία του συστήματος αρχείων και είναι σταθερός [iii]. Εξαρτάται από το μέγεθος του συστήματος αρχείων.

Θέσεις αποθήκευσης: Τα inodes αποθηκεύονται σε πίνακες inode (inode tables), τα οποία βρίσκονται σε κάθε block group. Κάθε block group έχει το δικό του inode table. Η θέση του inode table για κάθε block group αποθηκεύεται στον αντίστοιχο block group descriptor.

iii. Αναφέρατε δύο τρόπους για να εξάγουμε την πληροφορία του πόσα inodes ενός ext2
     συστήματος αρχείων είναι ελεύθερα.

Δύο τρόποι για να εξάγουμε τον αριθμό των ελεύθερων inodes:

Μέσω των block group descriptors: Διαβάζουμε το πεδίο bg_free_inodes_count από όλους τους block group descriptors και τα αθροίζουμε.

Μέσω των inode bitmaps: Διαβάζουμε όλα τα inode bitmaps και αθροίζουμε όλα τα μη μηδενικά bits

iv. Προσπαθείτε να δημιουργήσετε ένα νέο αρχείο σε ένα σύστημα αρχείων ext2 και λαμβάνετε
    μήνυμα σφάλματος ότι δεν υπάρχει διαθέσιμος χώρος στο δίσκο. Αναφέρατε δύο λόγους
    στους οποίους μπορεί να οφείλεται αυτό.

Δύο λόγοι για μήνυμα σφάλματος "δεν υπάρχει διαθέσιμος χώρος":

Δεν υπάρχουν διαθέσιμα blocks: Όλα τα data blocks στο σύστημα αρχείων είναι κατειλημμένα.

Δεν υπάρχουν διαθέσιμα inodes: Έχει εξαντληθεί ο αριθμός των διαθέσιμων inodes, δηλαδή δεν υπάρχουν ελεύθερα inodes για να δημιουργηθεί το νέο αρχείο.

v. Πόσα inodes χρειάζεται να προσπελαστούν ώστε να βρεθούν τα περιεχόμενα του αρχείου
   /dir1/dir2/file;

Αριθμός inodes που χρειάζεται να προσπελαστούν για το /dir1/dir2/file:

Χρειάζεται να προσπελαστούν τα inodes των καταλόγων /, /dir1, /dir2 και το inode του αρχείου file. Συνολικά, χρειάζεται να προσπελαστούν 4 inodes

vi. Κάθε φορά που δημιουργείται ένας καινούριος φάκελος σε ένα ext2 σύστημα αρχείων στο
    inode του αναφέρεται ότι υπάρχουν δύο hard links. Γιατί γίνεται αυτό και ποια είναι τα δύο
    “ονόματα” που αναφέρονται σε αυτό το inode.

Όταν δημιουργείται ένας νέος φάκελος, στο inode του αναφέρεται ότι υπάρχουν δύο hard links, επειδή:

Ο ίδιος ο φάκελος έχει ένα hard link μέσω του ονόματος του στον γονικό του κατάλογο.

Μέσα στον ίδιο το φάκελο υπάρχει ένας ειδικός κατάλογος με όνομα “.” (dot) που αναφέρεται στον εαυτό του, δημιουργώντας το δεύτερο hard link.

Επιπλέον, κάθε φάκελος περιέχει επίσης έναν κατάλογο ".." (dot dot) ο οποίος αναφέρεται στον γονικό κατάλογο.

---

**Θέμα 3 (30%)**

**α. (7%) Σωστό ή Λάθος: Αιτιολογήστε συνοπτικά την απάντησή σας.**

i. Όταν χρησιμοποιούμε την κλήση συστήματος unlink() διαγράφονται πάντα τα περιεχόμενα του αρχείου που περνάμε ως παράμετρο.

Λάθος. Η κλήση συστήματος unlink() δεν διαγράφει πάντα τα περιεχόμενα του αρχείου. Απλώς καταργεί τη σύνδεση (link) μεταξύ του ονόματος αρχείου και του inode του. Αν το αρχείο έχει μόνο ένα hard link και δεν υπάρχουν άλλες διεργασίες που το έχουν ανοιχτό, τότε το αρχείο και τα δεδομένα του διαγράφονται. Αλλιώς, τα δεδομένα παραμένουν μέχρι να διαγραφούν όλα τα hard links και να κλείσουν όλοι οι file descriptors που αναφέρονται στο αρχείο.

ii. Για το κλείδωμα κοινόχρηστων δομών που προσεγγίζονται και από κώδικα κάποιου interrupt handler χρησιμοποιούμε αποκλειστικά spinlocks.

Σωστό. Για τον συγχρονισμό κοινόχρηστων δομών που προσεγγίζονται από κώδικα σε interrupt context, χρησιμοποιούνται αποκλειστικά spinlocks, καθώς ο κώδικας σε interrupt context δεν επιτρέπεται να κοιμηθεί. Οι σηματοφορείς δεν είναι κατάλληλοι για interrupt context, επειδή η down() μπορεί να μπλοκάρει την διεργασία

iii. Μπορούμε πάντα να δούμε με την strace τις εγγραφές που πραγματοποιούνται από μία διεργασία σε ένα ανοιχτό αρχείο, ανεξαρτήτως της διεπαφής που χρησιμοποιήθηκε για την προσπέλαση του.

Λάθος. Η strace παρακολουθεί μόνο τις κλήσεις συστήματος που κάνει μια διεργασία. Εάν μια διεργασία προσπελάσει ένα αρχείο μέσω memory mapping (mmap), οι εγγραφές δεν θα καταγραφούν από την strace, διότι η προσπέλαση δεν γίνεται μέσω κλήσεων συστήματος όπως read() ή write()

iv. Δύο kernel threads που διαβάζουν ταυτόχρονα από την ίδια εικονική διεύθυνση χώρου πυρήνα (e.g. 0xffffab0e) μπορεί να διαβάσουν διαφορετικά δεδομένα.

Λάθος. Δύο kernel threads που διαβάζουν από την ίδια εικονική διεύθυνση στον χώρο του πυρήνα θα διαβάσουν τα ίδια δεδομένα, διότι η εικονική διεύθυνση αντιστοιχίζεται στην ίδια φυσική θέση μνήμης. Ο χώρος διευθύνσεων του πυρήνα είναι κοινός για όλες τις διεργασίες και τα threads του πυρήνα.

v. Ένας file descriptor συνδέεται πάντα με κάποιο αρχείο σε φυσική αποθηκεύση.

Λάθος. Ένας file descriptor συνδέεται με μια ανοιχτή δομή αρχείου (struct file), η οποία αναπαριστά ένα ανοιχτό αρχείο και όχι απαραίτητα με ένα αρχείο σε φυσική αποθήκευση. Για παράδειγμα, ένας file descriptor μπορεί να συνδέεται με ένα pipe, ένα socket, ή μια συσκευή χαρακτήρων. Ειδικά αρχεία, όπως αυτά στο /dev, επίσης δεν αντιστοιχούν σε αρχεία σε φυσική αποθήκευση, αλλά αποτελούν διεπαφές για συσκευές

---

**β. (5%)** Δύο διεργασίες έχουν ανοίξει το ίδιο αρχείο foo.txt καλώντας η κάθε μία την open(). Η διεργασία A χρησιμοποιεί την lseek() για να επεξεργαστεί τα τελευταία 1024 bytes του αρχείου. Η διεργασία B στη συνέχεια καλεί την read(). Από ποιο σημείο του αρχείου θα ξεκινήσει να διαβάζει η διεργασία B; Σε ποια δομή του ΛΣ αποθηκεύεται το file offset και πότε μπορεί να το μοιράζονται δύο διεργασίες;

Η διεργασία Β θα ξεκινήσει να διαβάζει από το σημείο του αρχείου στο οποίο βρίσκεται το file offset μετά την τελευταία λειτουργία ανάγνωσης/εγγραφής ή μετακίνησης (lseek) της διεργασίας B. Δεδομένου ότι η διεργασία Β δεν έχει κάνει κάποια ενέργεια μετακίνησης, θα διαβάσει από την αρχή. Η lseek() της διεργασίας Α δεν επηρεάζει το file offset της διεργασίας Β.

Το file offset αποθηκεύεται στη δομή struct file, στο πεδίο f_pos. Κάθε διεργασία έχει τη δική της δομή file και το δικό της file offset όταν ανοίγει το ίδιο αρχείο με την open().

Δύο διεργασίες μπορούν να μοιράζονται το ίδιο file offset μόνο αν έχουν δημιουργηθεί από την ίδια αρχική διεργασία και έχουν κληρονομήσει το file descriptor (π.χ., μέσω fork()). Τα νήματα (threads) της ίδιας διεργασίας επίσης μοιράζονται το ίδιο file offset.

---

**γ. (8%)** Στο φλοιό Linux εκτελείτε την παρακάτω εντολή: 

```bash
echo "bar" | cat > foo.txt
```

Τι κάνει και ποια system calls θα κληθούν κατά την εκτέλεση της και με ποια σειρά; Ποια διεργασία και με τι permissions ανοίγει το αρχείο foo.txt;

---

**Τι κάνει η εντολή:**  
Η εντολή εκτελεί τα εξής:
- Το `echo "bar"` παράγει την έξοδο "bar\n" στο standard output.
- Η pipe (`|`) ανακατευθύνει το output του echo στο stdin του `cat`.
- Η ανακατεύθυνση (`> foo.txt`) ανακατευθύνει το stdout του cat στο αρχείο foo.txt.
- Επιπλέον, αν υπήρχαν μηνύματα λάθους (stderr) του cat, με την εντολή `2>&1` θα ανακατευθυνθούν επίσης στο foo.txt.

**Ποια system calls καλούνται και με ποια σειρά (σε γενικές γραμμές):**

1. **pipe()** – Δημιουργία ενός pipe.
2. **fork()** – Δημιουργία παιδικής διεργασίας για το echo.
   - Στο παιδί:  
     - **dup2()** για ανακατεύθυνση του stdout στο pipe’s write end.
     - **close()** των περιττών file descriptors.
     - **execve("echo", ...)** για εκτέλεση του echo.
3. **fork()** – Δημιουργία δεύτερης παιδικής διεργασίας για το cat.
   - Στο παιδί:  
     - **dup2()** για ανακατεύθυνση του stdin στο pipe’s read end.
     - **open("foo.txt", O_WRONLY|O_CREAT|O_TRUNC, mode)** για να ανοίξει/δημιουργήσει το foo.txt (mode καθορίζεται από την umask, συχνά 0644 ή 0666).
     - **dup2()** για ανακατεύθυνση του stdout στο file descriptor του foo.txt.
     - **dup2()** για ανακατεύθυνση του stderr στο stdout (2>&1).
     - **close()** των περιττών descriptors.
     - **execve("cat", ...)** για εκτέλεση του cat.
4. Στον γονέα, κλείνουμε τα file descriptors του pipe και περιμένουμε τα παιδιά (wait()).

**Ποια διεργασία ανοίγει το foo.txt και με τι permissions:**  
Το foo.txt ανοίγεται από τη διεργασία που εκτελεί το **cat**, χρησιμοποιώντας open() με flags **O_WRONLY | O_CREAT | O_TRUNC**. Τα permissions καθορίζονται είτε ρητά (π.χ. 0644 ή S_IRWXU) είτε σύμφωνα με την umask του χρήστη.

---

**δ. (10%) Δίνεται το παρακάτω πρόγραμμα:**

```c
1  void main(void) {
2      int fd, i;
3      pid_t p;
4      char buf[4096];
5      unsigned long long sum;

6      fd = open("foo.txt", O_CREAT | O_RDWR);
7      p = fork();

9      if (p == 0) {
10         read(fd, buf, 4096);
11         for (i = 0; i < 4096; i++)
12             sum += buf[i];
13         write(fd, &sum, 8);
14     } else {
15         read(fd, buf, 4096);
16         for (i = 0; i < 4096; i++)
17             buf[i]++;
18         write(fd, buf, 4096);
19     }
20 }
```
**i. Τι κάνει το πρόγραμμα;**

- **Άνοιγμα αρχείου:** Το πρόγραμμα ανοίγει το αρχείο "foo.txt" με open() (χωρίς O_TRUNC, οπότε αν υπάρχει, δεν κόβεται).  
- **fork():** Δημιουργείται παιδική διεργασία.  
- **Κοινή χρήση file descriptor:** Οι δύο διεργασίες μοιράζονται το ίδιο open file description (δηλαδή, το ίδιο file offset).  
- **Στον παιδί (p == 0):**  
  - Καλεί read(fd, buf, 4096) για να διαβάσει 4096 bytes από το αρχείο, προχωρώντας το file offset στο τέλος της ανάγνωσης.  
  - Υπολογίζει το άθροισμα (sum) όλων των 4096 bytes του buf. (Σημείωση: Η μεταβλητή sum δεν έχει αρχικοποιηθεί και πρέπει να αρχικοποιηθεί στο 0 πριν το loop.)  
  - Γράφει το 8-byte sum στο αρχείο μέσω write(fd, &sum, 8).  
- **Στον γονέα (else):**  
  - Καλεί επίσης read(fd, buf, 4096) για να διαβάσει 4096 bytes, αλλά δεδομένου ότι το file offset είναι κοινό, η σειρά εκτέλεσης μεταξύ γονέα και παιδιού είναι απροσδιόριστη.  
  - Αυξάνει κάθε byte του buf κατά 1 και γράφει πίσω 4096 bytes στο αρχείο με write(fd, buf, 4096).

**Προβλήματα/Παρατηρήσεις:**

- Δεδομένου ότι οι διεργασίες μοιράζονται το ίδιο file offset (από το κοινό open file description), υπάρχει race condition: ποιος θα κάνει πρώτα το read() και το write() καθορίζει την τελική διάταξη των δεδομένων στο αρχείο.
- Η μεταβλητή `sum` δεν αρχικοποιείται στο 0, οδηγώντας σε απροσδιόριστη συμπεριφορά.
- Το αποτέλεσμα του προγράμματος είναι απροσδιόριστο λόγω κοινής χρήσης του file offset χωρίς συγχρονισμό.
