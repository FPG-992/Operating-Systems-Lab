**Θέμα 1 (40%)**

Εργάζεστε για την ανάπτυξη οδηγού συσκευής παρακολούθησης ασθενών σε νοσοκομεία. Το υλικό αποτελείται από ένα σύνολο αισθητήρων οι οποίοι τοποθετούνται στο σώμα των ασθενών και καταγράφουν στοιχεία, όπως θερμοκρασία σώματος, παλμούς, δείκτες αίματος κλπ. Τα δεδομένα αποστέλλονται σε σταθμό βάσης ο οποίος συνδέεται σε υπολογιστικό σύστημα με ΛΣ Linux. Το στρώμα συλλογής δεδομένων του οδηγού της συσκευής εκτελείται σε interrupt context και τοποθετεί τα δεδομένα σε δομή κυκλικού απομονωτή (circular buffer).

```c
struct medical_dev {
    ...locktype... lock;
    wait_queue_head_t wq;
    uint128_t cnt; /* This is initialized to zero and will never wrap. */

    #define CIRC_BUF_SIZE (1024 * sizeof(struct patient_data))
    char circ_buffer[CIRC_BUF_SIZE];
} medical_dev;
```

Τα στοιχεία κάθε μέτρησης αποθηκεύονται σε δομές τύπου `struct patient_data`, ενδεικτικού μεγέθους 64 bytes η κάθε μία. Δίνεται η συνάρτηση χειρισμού διακοπών:

```c
void intr(void)
{
    struct medical_dev *dev = &medical_dev;
    struct patient_data pd;

    get_patient_data_from_hw(&pd); /* Get data from the real device. */
    ... lock medical_dev ...
    memcpy(&dev->circ_buffer[dev->cnt % CIRC_BUF_SIZE], &pd,
           sizeof(struct patient_data));
    dev->cnt += sizeof(struct patient_data);
    ... unlock medical_dev ...
    wake_up_interruptible(&dev->wq);
}
```

Ο οδηγός υλοποιεί μία συσκευή χαρακτήρων `/dev/medical` και πρέπει να τηρεί τις παρακάτω προδιαγραφές:

1. Κάθε `read()` επιστρέφει bytes από το πολύ μία μέτρηση.
2. Διαδοχικές κλήσεις `read()` επιστρέφουν δεδομένα από χρονικά συνεχόμενες μετρήσεις που γράφτηκαν στον κυκλικό απομονωτή μόνο από τη στιγμή του `open()` και μετά, με τη σειρά που γράφτηκαν, ως ένα ρεύμα (stream) από bytes.
3. Αν για οποιοδήποτε λόγο δεν είναι δυνατή η ανάκτηση χρονικά συνεχόμενων μετρήσεων από δύο διαδοχικές `read()`, τότε η δεύτερη `read()` επιστρέφει EOF. Για την ανάκτηση νέου ρεύματος έγκυρων μετρήσεων πρέπει η διεργασία να κάνει `close()` και εκ νέου `open()`.
4. Όταν η διεργασία έχει διαβάσει πλήρως όλες τις διαθέσιμες μετρήσεις, κοιμάται μέχρι να εγγραφεί νέα μέτρηση στον κυκλικό απομονωτή από τη συνάρτηση χειρισμού διακοπών.

Δίνεται ο σκελετός του οδηγού. Θεωρείστε ότι οι κλήσεις για δέσμευση μνήμης καθώς και οι κλήσεις αντιγραφής μνήμης επιτυγχάνουν πάντα:

```c
struct chrdev_state {
    ...locktype... lock;
    struct medical_dev *medical_dev;

    char local_buf[sizeof(struct patient_data)];
    uint128_t local_cnt; /* Suppose it will never wrap. */
};

static int medical_chrdev_open(struct inode *inode, struct file *filp)
{
    struct chrdev_state *state;
    struct medical_dev *dev = &medical_dev;

    if (nonseekable_open(inode, filp) < 0)
        return -ENODEV;

    state = kmalloc(sizeof(struct chrdev_state), GFP_KERNEL);
    ... ??? ...
}
```
---

```c
static ssize_t medical_chrdev_read(struct file *filp, char __user *usrbuf,
                                   size_t cnt, loff_t *f_pos)
{
    struct chrdev_state *state;
    struct medical_dev *dev;

    state = filp->private_data;
    dev = state->medical_dev;

    ... ??? ...

    /* Do we need to fetch a fresh measurement? */
    if (*f_pos == 0) {
        ... ??? ...
    }

    ... ??? ...
}
```

**Ζητούνται τα εξής:**

i. (7%) Τι μετράει το πεδίο cnt της δομής `medical_dev`; Ποιος ο ρόλος των πεδίων lock και wq της ίδιας δομής; Τι τύπου είναι τα κλειδώματα των δομών `medical_dev` και `chrdev_state` και γιατί;

ii. (6%) Ποιος ο ρόλος της δομής `chrdev_state`; Εξηγήστε συνοπτικά τη χρησιμότητα των πεδίων `local_buf` και `local_cnt`. Πότε αρχικοποιείται το `local_cnt` και πότε αυξάνεται;

iii. (7%) Σε ποια περίπτωση δύο διαδοχικές `read()` δεν μπορούν να επιστρέψουν δεδομένα από χρονικά συνεχόμενες μετρήσεις, οπότε και η δεύτερη `read()` επιστρέφει EOF; Τι έχει συμβεί ανάμεσα στις κλήσεις των δύο `read()`;

iv. (20%) Υλοποιήστε τις `medical_chrdev_open()` και `medical_chrdev_read()` του οδηγού συσκευής. Εξηγήστε συνοπτικά πώς εξασφαλίζεται ότι ο οδηγός σας τηρεί τις τέσσερις προδιαγραφές που αναφέρονται παραπάνω.

---

## (i) Ανάλυση πεδίων της δομής *medical_dev*

1. **Το πεδίο `cnt`:**  
   - Αυτό το πεδίο είναι ένας μονοτονικά αυξανόμενος μετρητής (σε bytes) που μετράει το συνολικό πλήθος των bytes που έχουν γραφτεί στον κυκλικό απομονωτή από τη στιγμή που ξεκίνησε η λειτουργία (και, σύμφωνα με την υπόθεση, δεν θα τυλίξει ποτέ).  
   - Δε γράφουμε απλώς ένα μετρητή “μετρήσεων”, αλλά προσαυξάνουμε κατά το μέγεθος κάθε δομής μέτρησης (π.χ. 64 bytes), έτσι ώστε το `cnt` να δείχνει τη θέση στο buffer (με τη χρήση της πράξης modulo με το μέγεθος του buffer).

2. **Τα πεδία `lock` και `wq`:**  
   - **`lock`:** Χρησιμοποιείται για συγχρονισμό της πρόσβασης στον κυκλικό απομονωτή και στο πεδίο `cnt`. Αυτό είναι απαραίτητο γιατί η συνάρτηση χειρισμού διακοπών (interrupt handler) εκτελείται σε περιβάλλον όπου δεν επιτρέπονται λειτουργίες που “κοιμούνται” (sleep) και μπορεί να τρέξει ταυτόχρονα με κλήσεις από διεργασίες που διαβάζουν.  
   - **`wq` (wait queue):** Είναι μια δομή αναμονής που χρησιμοποιείται για να “κοιμούνται” διεργασίες που προσπαθούν να κάνουν read όταν δεν υπάρχουν διαθέσιμες μετρήσεις. Όταν η συνάρτηση διακοπών καταγράφει νέα δεδομένα, καλεί `wake_up_interruptible(&dev->wq)` για να ξυπνήσει τις διεργασίες που περιμένουν.

3. **Τύπος κλειδώματος στις δομές:**  
   - **Στη δομή `medical_dev`:** Το `lock` πρέπει να είναι **spinlock** (π.χ. `spinlock_t`) επειδή:
     - Χρησιμοποιείται σε περιβάλλον διακοπών (interrupt context) όπου δεν επιτρέπονται λειτουργίες που “κοιμούνται” (sleep).
     - Οι συνάρτησεις που τρέχουν σε interrupt context πρέπει να αποφεύγουν οποιαδήποτε λειτουργία που μπορεί να οδηγήσει σε sleep.
     - Must protect global device data in interrupt context.
  Spinlocks are non-sleeping, suitable for short critical sections in interrupts.
   - **Στη δομή `chrdev_state`:** Το `lock` (αν χρησιμοποιείται) προστατεύει την κατάσταση που ανήκει στο ανοικτό αρχείο. Δεδομένου ότι οι λειτουργίες read() εκτελούνται σε διεργασιακό (process) context, σε περίπτωση που απαιτείται συγχρονισμός μεταξύ πιθανών ταυτόχρονων κλήσεων read από τον ίδιο descriptor (ή από πολλαπλά νήματα που μοιράζονται την ίδια κατάσταση), μπορεί να χρησιμοποιηθεί είτε ένας **mutex** (sleepable lock) είτε, αν απαιτείται πολύ γρήγορη προστασία χωρίς sleep, ένας spinlock – αλλά **δεν πρέπει να κρατάται ενώ η διεργασία κοιμάται**. Συνήθως, επειδή η κατάσταση είναι per-open (και συνήθως δεν μοιράζεται μεταξύ πολλών ταυτόχρονων κλήσεων), δεν απαιτείται πολύ “βαρύ” κλείδωμα ή μπορεί να χρησιμοποιηθεί ένας mutex.
   - Protects per‐open data in the read()/write() code paths, which can block.
   - Sleeping locks (e.g., semaphores, mutexes) are allowed in user context.
   - chrdev_state->lock = Semaphore/Mutex
---

## (ii) Ο ρόλος της δομής *chrdev_state* και των πεδίων της

- **Ρόλος της δομής `chrdev_state`:**  
  Αυτή η δομή περιέχει την κατάσταση που σχετίζεται με κάθε ανοικτή συσκευή χαρακτήρων. Δηλαδή, κάθε φορά που ένα πρόγραμμα ανοίγει το `/dev/medical`, δημιουργείται μια δική του κατάσταση που περιέχει πληροφορίες ώστε οι κλήσεις read() να παρακολουθούν τη χρονική σειρά των μετρήσεων που γράφτηκαν από το χρόνο του open και μετά.

- **Πεδίο `local_buf`:**  
  - Χρησιμοποιείται ως τοπικό buffer για την αποθήκευση μιας μετρήσεως (δηλαδή, μιας δομής `struct patient_data`) όταν αυτή ανακτηθεί από τον κυκλικό απομονωτή.  
  - Στη συνέχεια, η συνάρτηση read() χρησιμοποιεί αυτόν τον buffer για να αντιγράψει τα bytes στο user-space (πιθανώς σε πολλές κλήσεις, εάν ο χρήστης ζητάει μόνο μέρος της μετρήσεως κάθε φορά).

- **Πεδίο `local_cnt`:**  
  - Αποτελεί δείκτη (offset) στην παγκόσμια ροή δεδομένων του κυκλικού απομονωτή, δηλαδή δείχνει τη θέση (σε bytes) για την επόμενη μετρήση που πρέπει να ανακτηθεί για αυτή τη συγκεκριμένη συνεδρία ανοίγματος.  
  - **Αρχικοποίηση:** Κατά την εκτέλεση του open(), δηλαδή μέσα στη `medical_chrdev_open()`, το `local_cnt` τίθεται ίσο με την τρέχουσα τιμή του `dev->cnt` ώστε να “αγνοήσει” τις μετρήσεις που είχαν καταγραφεί πριν το open().  
  - **Αύξηση:** Κάθε φορά που ολοκληρώνεται μια ανάγνωση μίας πλήρους μετρήσεως (δηλαδή, όταν τα bytes για μία δομή έχουν παραδοθεί στον χρήστη), το `local_cnt` αυξάνεται κατά `sizeof(struct patient_data)`, ώστε η επόμενη ανάγνωση να αναζητήσει την επόμενη χρονικά συνεχή μέτρηση.

---

## (iii) Διακοπές στην ακολουθία των διαδοχικών read()

Οι δύο διαδοχικές κλήσεις read() θα επιστρέψουν χρονικά συνεχόμενες μετρήσεις μόνο εάν το περιεχόμενο του κυκλικού απομονωτή δεν έχει “ανορθολογιστεί” μεταξύ των κλήσεων. Συγκεκριμένα:

- **Περίπτωση που δεν πληρούνται οι χρονικές συνεχείς μετρήσεις:**  
  Εάν, μεταξύ της πρώτης και της δεύτερης κλήσης read(), ο διακόπτης (interrupt handler) καταγράφει επιπλέον μετρήσεις στο κυκλικό απομονωτή (π.χ. λόγω υψηλού ρυθμού εισόδου ή καθυστέρησης στην ανάγνωση), τότε το `dev->cnt` θα έχει αυξηθεί περισσότερο από το αναμενόμενο (δηλαδή, περισσότερα από `sizeof(struct patient_data)` bytes από την τιμή που είχε όταν ξεκίνησε η ανάγνωση της προηγούμενης μέτρησης).  
  - Αυτό σημαίνει ότι ο επόμενος αναμενόμενος δείκτης `local_cnt` δεν αντιστοιχεί πλέον στην αμέσως επόμενη χρονικά μέτρηση, διότι κάποιες μετρήσεις έχουν “χαθεί” (υπεργραμμιστεί) ή παραλείπονται.  
  - **Συμπέρασμα:** Σε αυτήν την περίπτωση, για να τηρηθεί η προδιαγραφή ότι οι διαδοχικές κλήσεις πρέπει να επιστρέφουν δεδομένα από συνεχόμενες χρονικά μετρήσεις, η δεύτερη κλήση read() επιστρέφει EOF (δηλαδή 0 bytes) ως ένδειξη ότι έχει διακοπεί η χρονική συνέχεια.

- **Τι έχει συμβεί ανάμεσα στις δύο κλήσεις:**  
  Ο διακόπτης (interrupt handler) έχει εκτελεστεί αρκετές φορές και έχει ενημερώσει τόσο τον κυκλικό απομονωτή όσο και το `dev->cnt` με περισσότερα δεδομένα από αυτά που αναμενόταν να παραδοθούν στην επόμενη κλήση read(). Αυτό μπορεί να οφείλεται σε καθυστέρηση στην ανάγνωση ή σε πολύ υψηλό ρυθμό καταγραφής, οδηγώντας σε “απόκλιση” (gap) στα δεδομένα.

---

## (iv) Υλοποίηση των συναρτήσεων medical_chrdev_open() και medical_chrdev_read()

Παρακάτω δίνεται μια πιθανή υλοποίηση με σχολιασμό που εξηγεί πώς εξασφαλίζεται ότι πληρούνται οι παρακάτω προδιαγραφές:

- **Προδιαγραφές:**
  1. Κάθε read() επιστρέφει από το πολύ μία μέτρηση.
  2. Οι διαδοχικές κλήσεις read() επιστρέφουν μετρήσεις γραμμένες μετά το open(), με τη σωστή σειρά.
  3. Εάν δεν είναι δυνατή η ανάκτηση συνεχόμενων μετρήσεων, η δεύτερη read() επιστρέφει EOF.
  4. Όταν δεν υπάρχουν διαθέσιμες μετρήσεις, η διαδικασία κοιμάται μέχρι να εγγραφεί νέα μέτρηση.

### Κώδικας για medical_chrdev_open():

```c
static int medical_chrdev_open(struct inode *inode, struct file *filp)
{
    struct chrdev_state *state;
    struct medical_dev *dev = &medical_dev;

    if (nonseekable_open(inode, filp) < 0)
        return -ENODEV;

    state = kmalloc(sizeof(*state), GFP_KERNEL);
    if (!state)
        return -ENOMEM;

    state->medical_dev = dev;

    /* Initialize the per‑open semaphore (binary semaphore) */
    sema_init(&state->lock, 1);

    /* Use the global spinlock to safely copy the current dev->cnt into state->local_cnt */
    spin_lock(&dev->lock);
    state->local_cnt = dev->cnt;
    spin_unlock(&dev->lock);
    
    filp->private_data = state;
    return 0;
}
```


### Κώδικας για medical_chrdev_read():

```c
static ssize_t medical_chrdev_read(struct file *filp, char __user *usrbuf,
                                   size_t cnt, loff_t *f_pos)
{
    struct chrdev_state *state = filp->private_data;
    struct medical_dev *dev = state->medical_dev;
    size_t meas_size = sizeof(struct patient_data);
    ssize_t bytes_to_copy;

    /*
     * We use the loff_t *f_pos to track the offset within the current measurement.
     * A value of 0 means that a new measurement should be fetched.
     */
    if (*f_pos == 0) {
        /* Lock the device lock to check for a new measurement */
        spin_lock(&dev->lock);

        /* Check if a complete new measurement is available */
        if (dev->cnt - state->local_cnt < meas_size) {
            spin_unlock(&dev->lock);
            /* If the device is non-blocking, return -EAGAIN */
            if (filp->f_flags & O_NONBLOCK)
                return -EAGAIN;
            /* Block (sleep) until a new measurement is recorded */
            if (wait_event_interruptible(dev->wq,
                (dev->cnt - state->local_cnt) >= meas_size) < 0)
                return -ERESTARTSYS;
            /* Reacquire the spinlock to re-check the condition */
            spin_lock(&dev->lock);
        }

        /*
         * Check for consistency: there must be exactly one new measurement.
         * If more have accumulated (i.e. the sequence was broken), return EOF.
         */
        if (dev->cnt - state->local_cnt != meas_size) {
            spin_unlock(&dev->lock);
            return 0;  /* EOF: the sequence has been broken */
        }

        /*
         * Now, acquire the per‑open state semaphore to safely update the local buffer
         * and the local counter.
         */
        if (down_interruptible(&state->lock)) {
            spin_unlock(&dev->lock);
            return -ERESTARTSYS;
        }

        /* Copy the new measurement from the circular buffer into the local buffer */
        memcpy(state->local_buf,
               &dev->circ_buffer[state->local_cnt % CIRC_BUF_SIZE],
               meas_size);
        /* Advance the pointer for the next measurement */
        state->local_cnt += meas_size;

        /* Release the per‑open state semaphore and then the global device lock */
        up(&state->lock);
        spin_unlock(&dev->lock);
    }

    /* Copy bytes from the local buffer to user space based on the offset *f_pos */
    bytes_to_copy = min(cnt, meas_size - *f_pos);
    if (copy_to_user(usrbuf, state->local_buf + *f_pos, bytes_to_copy))
        return -EFAULT;
    
    *f_pos += bytes_to_copy;
    /* If the entire measurement has been read, reset *f_pos for the next measurement */
    if (*f_pos >= meas_size)
        *f_pos = 0;
    
    return bytes_to_copy;
}

```

### Επεξήγηση πώς εξασφαλίζονται οι προδιαγραφές:

1. **Κάθε read() επιστρέφει από το πολύ μία μέτρηση:**  
   - Μεταφέρουμε μία ολόκληρη μέτρηση (δηλαδή, sizeof(struct patient_data) bytes) στον `local_buf` και στη συνέχεια, τα bytes αυτής της μέτρησης διαβιβάζονται στον χρήστη μέσω του offset *f_pos.
   
2. **Διαδοχικές κλήσεις read() επιστρέφουν μετρήσεις από χρονικά συνεχόμενες εγγραφές (από το χρόνο του open και μετά):**  
   - Στο open(), το `local_cnt` αρχικοποιείται στο τρέχον `dev->cnt`, ώστε οι μετρήσεις που υπήρχαν πριν το open() να αγνοηθούν.
   - Κάθε φορά που διαβάζεται μία μέτρηση, το `local_cnt` αυξάνεται κατά το μέγεθος της μέτρησης, διασφαλίζοντας ότι διαβάζονται μετρήσεις με τη σειρά που γράφτηκαν.
   
3. **Αν δεν είναι δυνατή η ανάκτηση συνεχόμενων μετρήσεων, η δεύτερη read() επιστρέφει EOF:**  
   - Πριν από κάθε ανάγνωση νέας μέτρησης, γίνεται έλεγχος (μέσω του `dev->cnt - state->local_cnt`) ώστε να διαπιστωθεί ότι υπάρχει ακριβώς μία νέα μέτρηση. Αν αυτός ο αριθμός είναι μεγαλύτερος (ή μικρότερος), σημαίνει ότι είτε δεν έχει καταγραφεί ακόμα πλήρης μέτρηση είτε έχουν “χαθεί” μετρήσεις (λόγω υπερχείλισης του buffer), και επομένως επιστρέφεται 0 (EOF).
   
4. **Όταν δεν υπάρχουν διαθέσιμες μετρήσεις, η διεργασία κοιμάται μέχρι να εγγραφεί νέα μέτρηση:**  
   - Εάν δεν υπάρχει επαρκής δεδομένα (δηλαδή, αν `dev->cnt - state->local_cnt` είναι μικρότερο από το μέγεθος της μέτρησης), η διεργασία αποδεσμεύει το spinlock και καλεί `wait_event_interruptible()` στην wait queue `dev->wq`. Όταν η συνάρτηση διακοπών (interrupt handler) καλέσει `wake_up_interruptible(&dev->wq)` μετά από νέα εγγραφή, η διεργασία ξυπνά και συνεχίζει την ανάγνωση.

---

## Συνοψίζοντας

- Το `cnt` στη δομή *medical_dev* μετράει το συνολικό πλήθος των bytes που έχουν γραφτεί στον κυκλικό απομονωτή, χρησιμοποιώντας το modulo για να εντοπίσει τη θέση μέσα στον buffer.
- Το `lock` προστατεύει τον κοινό buffer και το `cnt` από ταυτόχρονες τροποποιήσεις (ιδιαιτέρως επειδή ο interrupt handler και οι λειτουργίες από διεργασία μπορούν να τρέχουν ταυτόχρονα), ενώ το `wq` επιτρέπει στις διεργασίες που κάνουν read να κοιμούνται όταν δεν υπάρχουν νέες μετρήσεις.
- Τα κλειδώματα στην *medical_dev* χρησιμοποιούν spinlock (απαραίτητο για την εκτέλεση σε interrupt context), ενώ το κλείδωμα σε *chrdev_state* μπορεί να είναι ένας sleepable lock (π.χ. mutex) εάν χρειάζεται, αλλά συχνά η κατάσταση είναι per-open και δεν απαιτεί πολυπλοκό συγχρονισμό.

---


**Θέμα 2 (35%)**

**α. (12%) Σωστό ή Λάθος: Αιτιολογήστε συνοπτικά την απάντησή σας.**

i. Στο σύστημα αρχείων ext2 το inode table καταλαμβάνει ένα ή και περισσότερα blocks του συστήματος αρχείων.

Σωστό. Στο σύστημα αρχείων ext2, το inode table είναι μια περιοχή αποθήκευσης που περιέχει μια σειρά από inodes, και καταλαμβάνει ένα ή και περισσότερα blocks, ανάλογα με το μέγεθος του inode και του block

ii. Στο σύστημα αρχείων ext2 το inode bitmap ενός block group μπορεί να καταλαμβάνει περισσότερα του ενός block στο σύστημα αρχείων.

Λάθος. Στο σύστημα αρχείων ext2, το inode bitmap ενός block group καταλαμβάνει ακριβώς ένα block. Κάθε bit του bitmap αντιστοιχεί σε ένα inode του block group, υποδεικνύοντας αν είναι ελεύθερο ή χρησιμοποιείται.

iii. Το Linux υποστηρίζει μόνο ένα συγκεκριμένο σύστημα αρχείων.

Λάθος. Το Linux υποστηρίζει πολλαπλά συστήματα αρχείων. Αυτά περιλαμβάνουν συστήματα αρχείων για συσκευές μόνιμης αποθήκευσης (ext2, ext3, ext4, NTFS, FAT), δικτυακά συστήματα αρχείων (NFS, sshfs, CIFS), και ειδικά συστήματα αρχείων (procfs, devtmpfs). Το VFS (Virtual File System) επιτρέπει την προσθήκη νέων συστημάτων αρχείων, ακόμη και δυναμικά μέσω modules.  

iv. Σε ένα σύστημα αρχείων ext2 ο συνολικός αριθμός inodes σε ένα σύστημα αρχείων καθορίζεται μόνο κατά τη δημιουργία του συστήματος αρχείων και δε μπορεί να αλλάξει αργότερα.

Σωστό. Ο συνολικός αριθμός των inodes σε ένα σύστημα αρχείων ext2 καθορίζεται κατά τη δημιουργία του και δεν μπορεί να αλλάξει αργότερα. Αυτός ο αριθμός καθορίζεται από το μέγεθος του συστήματος αρχείων και τον αριθμό των inodes ανά block group.

v. Στο σύστημα αρχείων ext2 υπάρχει ένα μοναδικό superblock σε συγκεκριμένο σημείο του δίσκου.

Λάθος. Στο ext2, υπάρχει ένα κύριο superblock και εφεδρικά αντίγραφα του. Τα εφεδρικά αντίγραφα βρίσκονται σε συγκεκριμένα block groups, επιτρέποντας την ανάκτηση δεδομένων σε περίπτωση βλάβης του κύριου superblock

vi. Σε έναν δίσκο με σύστημα αρχείων ext2 το superblock αποθηκεύεται στην αρχή του δίσκου.
Λάθος. Το superblock δεν αποθηκεύεται στην αρχή του δίσκου, αλλά μετά το boot sector. Το boot sector καταλαμβάνει τα πρώτα 1024 bytes και μετά ξεκινά η λίστα των block groups, με το superblock στο πρώτο block group

vii. Σε ένα σύστημα αρχείων ext2 ένα inode ενός αρχείου περιέχει και το όνομα του αρχείου.

Λάθος. Ένα inode περιέχει μεταδεδομένα για ένα αρχείο, αλλά όχι το όνομά του. Το όνομα του αρχείου αποθηκεύεται στα directory entries που βρίσκονται μέσα στα data blocks των καταλόγων. Οι directory entries συνδέουν το όνομα του αρχείου με το αντίστοιχο inode.

viii. Σε ένα σύστημα αρχείων ext2 το μέγεθος ενός inode καθορίζεται μόνο κατά τη δημιουργία του συστήματος αρχείων και δε μπορεί να αλλάξει αργότερα.

Σωστό. Σε παλαιότερες εκδόσεις του ext2, το μέγεθος ενός inode ήταν σταθερό στα 128 bytes. Ωστόσο, σε νεότερες εκδόσεις, το μέγεθος του inode μπορεί να καθοριστεί κατά τη δημιουργία του συστήματος αρχείων.

---

**β. (23%) Απαντήστε συνοπτικά στις παρακάτω ερωτήσεις:**

i. Αναφέρατε δύο σημεία μέσα σε ένα σύστημα αρχείων ext2 από όπου μπορούμε να εξάγουμε την πληροφορία του πόσα inodes ενός ext2 συστήματος αρχείων είναι ελεύθερα.

- **Από το superblock:** Το πεδίο `s_free_inodes_count` περιέχει τον συνολικό αριθμό ελεύθερων inodes.
- **Από το inode bitmap κάθε block group:** Μετρώντας τα bits που δείχνουν "ελεύθερες" inodes (συνήθως 0).

ii. Τι είναι το superblock; Σε ποια θέση αποθηκεύεται σε ένα διαμέρισμα ενός δίσκου που περιέχει ένα ext2 σύστημα αρχείων; Αναφέρατε τρία πεδία του καθώς και τι αναπαριστά το καθένα από αυτά.

- **Ορισμός:** Το superblock είναι μια δομή που περιέχει κρίσιμες πληροφορίες για το file system (π.χ. αριθμοί blocks, inodes, μέγεθος block, κλπ.).
   - **Θέση αποθήκευσης:** Ο πρωτεύων superblock αποθηκεύεται στο offset 1024 bytes από την αρχή του partition.
   - **Παραδείγματα πεδίων:**
     - `s_blocks_count`: Ο συνολικός αριθμός blocks στο file system.
     - `s_free_inodes_count`: Ο αριθμός των ελεύθερων inodes.
     - `s_log_block_size`: Ο λογαριθμικός δείκτης για το block size (π.χ. το block size = 1024 << s_log_block_size).

iii. Τι είναι το inode; Πόσα υπάρχουν σε ένα διαμέρισμα ενός δίσκου που περιέχει ένα ext2 σύστημα αρχείων; Σε ποιες θέσεις αποθηκεύονται μέσα στο δίσκο;

- **Ορισμός:** Το inode είναι μια δομή που αποθηκεύει τα metadata ενός αρχείου (όπως δικαιώματα, timestamps, pointers σε data blocks, κ.λπ.).
- **Αριθμός inodes:** Ο συνολικός αριθμός ορίζεται στο superblock (s_inodes_count) κατά τη δημιουργία του file system.
- **Θέσεις αποθήκευσης:** Τα inodes αποθηκεύονται στους inode tables που βρίσκονται σε κάθε block group του file system.

iv. Πόσα inodes χρειάζεται να προετοιμαστούν ώστε να βρεθούν τα περιεχόμενα του αρχείου `/dir1/dir2/file`;

- **Απάντηση:** Θα χρειαστούν τα inodes για: 
     - τον root φάκελο `/`,
     - τον φάκελο `/dir1`,
     - τον φάκελο `/dir1/dir2`,
     - και τέλος το inode για το αρχείο `file`.  
     Δηλαδή συνολικά **4 inodes** (υποθέτοντας ότι ξεκινάμε από τον root φάκελο).

v. Κάθε φορά που δημιουργείται ένας καινούριος φάκελος σε ένα ext2 σύστημα αρχείων στο inode που αναφέρεται ότι υπάρχουν δύο hard links. Γιατί γίνεται αυτό και ποια είναι τα δύο "ονόματα" που αναφέρονται σε αυτό το inode;

- **Αιτιολόγηση:** Κάθε φάκελος έχει δύο καταχωρήσεις: 
     - το `"."` που δείχνει στον εαυτό του,
     - και το `".."` που δείχνει στον γονικό του φάκελο.  
     Αυτός ο διπλός αριθμός hard links (τουλάχιστον) είναι απαραίτητος για την ορθή πλοήγηση στο directory tree.

vi. Προσπαθείτε να δημιουργήσετε ένα νέο αρχείο σε ένα σύστημα αρχείων ext2 και λαμβάνετε μήνυμα σφάλματος ότι δεν υπάρχει διαθέσιμος χώρος στο δίσκο. Αναφέρετε δύο λόγους στους οποίους μπορεί να οφείλεται αυτό.

- **Ελλείψεις Data Blocks:** Δεν υπάρχουν ελεύθερα blocks στον χώρο δεδομένων για την αποθήκευση του περιεχομένου του αρχείου.
- **Εξαντλημένοι Inodes:** Ο συνολικός αριθμός inodes έχει εξαντληθεί (δηλαδή, δεν υπάρχουν ελεύθερα inodes), παρόλο που ίσως υπάρχουν ελεύθερα blocks.

---

**Θέμα 3 (25%)**

**α. (5%) Σωστό ή Λάθος: Αιτιολογήστε συνοπτικά την απάντησή σας.**

i. Οι κλήσεις συστήματος εκτελούνται πάντα σε process context.

Λάθος. Οι κλήσεις συστήματος εκτελούνται αρχικά σε process context, καθώς καλούνται από μια διεργασία χρήστη. Ωστόσο, μέρος του κώδικα του πυρήνα που εκτελείται στα πλαίσια μιας κλήσης συστήματος μπορεί να μεταβεί σε interrupt context. Για παράδειγμα, ένας οδηγός συσκευής που εξυπηρετεί μια κλήση συστήματος, μπορεί να χρειαστεί να απαντήσει σε μια διακοπή υλικού.

ii. Κώδικας που εκτελείται σε interrupt context επιτρέπεται να καλέσει την down_interruptible().

Λάθος. Κώδικας που εκτελείται σε interrupt context δεν επιτρέπεται να καλέσει τη συνάρτηση down_interruptible(). Η down_interruptible() μπορεί να θέσει την τρέχουσα διεργασία σε κατάσταση αναμονής, κάτι που είναι απαγορευμένο σε interrupt context. Στο interrupt context δεν υπάρχει διεργασία που να μπορεί να κοιμηθεί.

iii. Όταν χρησιμοποιούμε την κλήση συστήματος unlink() διαγράφονται πάντα τα περιεχόμενα του αρχείου που περνάμε ως παράμετρο.

Λάθος. Η κλήση συστήματος unlink() χρησιμοποιείται για τη διαγραφή της σύνδεσης ενός ονόματος αρχείου με το αντίστοιχο inode του. Αν δεν υπάρχουν άλλες συνδέσεις (hard links) προς το inode, τότε το αρχείο θα διαγραφεί και ο χώρος που καταλαμβάνουν τα δεδομένα του θα ελευθερωθεί. Ωστόσο, αν υπάρχουν άλλες συνδέσεις (hard links) προς το αρχείο, τότε μόνο η σύνδεση που καθορίζεται στην unlink() θα διαγραφεί και τα περιεχόμενα του αρχείου δεν θα διαγραφούν.

iv. Η χρήση spinlocks σε χώρο πυρήνα επιτρέπεται μόνο για τον αμοιβαίο αποκλεισμό μεταξύ κομματιών κώδικα που εκτελούνται σε process context.

Λάθος. Τα spinlocks χρησιμοποιούνται για αμοιβαίο αποκλεισμό μεταξύ τμημάτων κώδικα που εκτελούνται σε process context και interrupt context. Τα spinlocks είναι κατάλληλα για χρήση σε interrupt context επειδή ο κώδικας που δεν μπορεί να πάρει το spinlock θα προσπαθεί συνεχώς μέχρι να τα καταφέρει, χωρίς να αφήσει τη CPU. Αυτό είναι απαραίτητο σε interrupt context, όπου δεν επιτρέπεται ο κώδικας να κοιμηθεί.

v. Οι σωληνώσεις που δημιουργούνται μέσω της κλήσης συστήματος pipe() μπορούν να χρησιμοποιηθούν μόνο μεταξύ γονικής διεργασίας και των παιδιών της.

Λάθος. Οι σωληνώσεις (pipes) που δημιουργούνται με την κλήση συστήματος pipe() μπορούν να χρησιμοποιηθούν για επικοινωνία μεταξύ οποιωνδήποτε διεργασιών, όχι μόνο μεταξύ γονικών και θυγατρικών. Αρκεί οι διεργασίες να έχουν πρόσβαση στους ίδιους file descriptors που αναφέρονται στις σωληνώσεις.
---

**β. (10%) Εκτελέστε την ακόλουθη εντολή στο φλοιό του Linux:**

```bash
$ cat foo | grep bar > out 2>&1
```

Η παραπάνω εντολή ανακατευθύνει το output της cat στη grep και στη συνέχεια ανακατευθύνει το stdout και stderr της grep στο αρχείο out. Σκιαγραφήστε πώς υλοποιεί ο φλοιός τις δύο ανακατευθύνσεις. Ποιες κλήσεις συστήματος θα εκτελεστούν και με ποια σειρά; Πόσες διεργασίες θα δημιουργηθούν; Ποιος και με τι permissions ανοίγει τα αρχεία foo και out;

#### Πώς υλοποιεί ο φλοιός (shell) αυτές τις ανακατευθύνσεις;

1. **Δημιουργία Pipeline:**
   - Ο φλοιός καλεί το system call **pipe()** για να δημιουργήσει ένα pipe. Αυτό επιστρέφει έναν πίνακα δύο file descriptors (π.χ. `pipefd[0]` για ανάγνωση και `pipefd[1]` για εγγραφή).

2. **Fork και Εκτέλεση των Εντολών:**
   - Ο φλοιός δημιουργεί δύο παιδικές διεργασίες με **fork()**:
     - **Πρώτο παιδί (για `cat foo`):**
       - **Redirection:** Καλεί **dup2(pipefd[1], STDOUT_FILENO)** ώστε η έξοδος του `cat` να κατευθυνθεί στο τέλος του pipe.
       - Κλείνει τα περιττά descriptors (π.χ. `pipefd[0]` και το αρχικό `pipefd[1]`).
       - Εκτελεί με **execve()** την εντολή `cat` με παράμετρο το "foo". (Η εντολή ανοίγει το αρχείο **foo** από τον ίδιο τον πρόγραμμα cat, με δικαιώματα ανάγνωσης, σύμφωνα με τα permissions του χρήστη που εκτελεί τη διεργασία.)
     - **Δεύτερο παιδί (για `grep bar`):**
       - **Redirection:** Καλεί **dup2(pipefd[0], STDIN_FILENO)** ώστε το stdin να παίρνει τα δεδομένα από το pipe.
       - Για την ανακατεύθυνση της εξόδου:
         - Ανοίγει το αρχείο **out** με **open("out", O_WRONLY | O_CREAT | O_TRUNC, mode)**, όπου ο mode είναι συνήθως S_IRWXU (δηλαδή, δικαιώματα read, write, execute για τον ιδιοκτήτη).
         - Καλεί **dup2(fd_out, STDOUT_FILENO)** ώστε το stdout να ανακατευθύνεται στο αρχείο **out**.
         - Για να ανακατευθυνθεί και το stderr, καλεί **dup2(STDOUT_FILENO, STDERR_FILENO)** (ή, ισοδύναμα, μετά την ανακατεύθυνση του stdout).
       - Κλείνει τα περιττά file descriptors (π.χ. το pipefd[1] και το pipefd[0] αφού έχουν αντικατασταθεί).
       - Εκτελεί με **execve()** την εντολή `grep` με παράμετρο το "bar".
       
3. **Διεργασίες και Επαναφορά:**
   - Ο αρχικός (γονικός) φλοιός κλείνει τα file descriptors του pipe και περιμένει (με **wait()** ή **waitpid()**) για να τερματίσουν οι δύο παιδικές διεργασίες.

#### Σύνοψη των System Calls και της σειράς τους:

- **pipe()**: Δημιουργία pipe.
- **fork()**: Δημιουργία του πρώτου παιδιού για `cat`.
  - Στο παιδί:
    - **dup2(pipefd[1], STDOUT_FILENO)**
    - **close()** στα περιττά fds.
    - **execve("cat", ["cat", "foo", NULL], …)**
- **fork()**: Δημιουργία του δεύτερου παιδιού για `grep`.
  - Στο παιδί:
    - **dup2(pipefd[0], STDIN_FILENO)**
    - **open("out", O_WRONLY|O_CREAT|O_TRUNC, S_IRWXU)**
    - **dup2(fd_out, STDOUT_FILENO)**
    - **dup2(STDOUT_FILENO, STDERR_FILENO)**
    - **close()** στα περιττά fds.
    - **execve("grep", ["grep", "bar", NULL], …)**
- Στον γονέα: **close()** στα fds του pipe και **wait()** για τα παιδιά.

#### Δημιουργούμενες διεργασίες:
- Δημιουργούνται **δύο παιδικές διεργασίες** (μία για `cat` και μία για `grep`). Ο γονικός φλοιός παραμένει και διαχειρίζεται τα fork/exec και την αναμονή.

#### Ποιος ανοίγει τα αρχεία και με τι permissions:
- Το **"foo"** ανοίγεται από το πρόγραμμα **cat** όταν του δίνεται ως παράμετρος (μέσω του argv). Ο cat ανοίγει το αρχείο με δικαιώματα ανάγνωσης σύμφωνα με το περιβάλλον του χρήστη.
- Το **"out"** ανοίγεται από το παιδί που εκτελεί το **grep**, χρησιμοποιώντας την κλήση open() με flags **O_WRONLY | O_CREAT | O_TRUNC** και mode (π.χ.) **S_IRWXU** (read, write, execute για τον ιδιοκτήτη).

---

**γ. (10%) Δίνεται το παρακάτω πρόγραμμα:**

```c
1  int main (int argc, char *argv[]) {
2      char buf[1024];
3      int fd = open("./file", O_CREAT | O_RDWR | O_TRUNC, S_IRWXU);
4      memset(buf, 'd', 1024);
5      lseek(fd, 4096, SEEK_SET);
6      write(fd, &buf, 1024);
7      close(fd);
8  }
```

**Υποθέστε ότι το αρχείο `./file` αρχικά δεν υπάρχει.**

i. Τι κάνει το παραπάνω πρόγραμμα;

ii. Ξαναγράψτε το πρόγραμμα ώστε να μην είναι εφικτό κάποιος να δει τι γράφετε στο αρχείο με χρήση της `strace`.

### Θέμα 3, γ. (10%)

#### Μέρος (i): Τι κάνει το παραπάνω πρόγραμμα;

Το πρόγραμμα:

```c
1  int main (int argc, char *argv[]) {
2      char buf[1024];
3      int fd = open("./file", O_CREAT | O_RDWR | O_TRUNC, S_IRWXU);
4      memset(buf, 'd', 1024);
5      lseek(fd, 4096, SEEK_SET);
6      write(fd, &buf, 1024);
7      close(fd);
8  }
```

**Ανάλυση:**

- **Γραμμή 3:** Ανοίγει (ή δημιουργεί, αν δεν υπάρχει) το αρχείο `./file` σε λειτουργία read-write και το κόβει (truncate) στο μηδέν, δίνοντας δικαιώματα S_IRWXU (read, write, execute για τον ιδιοκτήτη).
- **Γραμμή 4:** Γεμίζει τον buffer `buf` με τον χαρακτήρα `'d'` (1024 bytes).
- **Γραμμή 5:** Μετακινεί το file pointer στο offset 4096 (δηλαδή, δημιουργείται ένα "hole" από 0 έως 4095). Στα περισσότερα συστήματα, όταν δημιουργείται ένα hole, αυτό διαβιβάζεται ως 0 όταν διαβάζεται.
- **Γραμμή 6:** Γράφει 1024 bytes από το buffer στο αρχείο, ξεκινώντας από το offset 4096.
- **Γραμμή 7:** Κλείνει το αρχείο.

**Συμπέρασμα:** Το πρόγραμμα δημιουργεί ένα sparse αρχείο με συνολικό "λογικό" μέγεθος 4096 + 1024 = 5120 bytes, όπου οι πρώτοι 4096 bytes είναι holes (συνήθως εμφανίζονται ως 0) και τα επόμενα 1024 bytes περιέχουν τον χαρακτήρα `'d'`.

---

#### Μέρος (ii): Αναδιατύπωση του προγράμματος ώστε να μην είναι εύκολο να δει κάποιος τι γράφετε στο αρχείο με χρήση της strace (με χρήση mmap)

Η ιδέα είναι να χρησιμοποιήσουμε το **mmap()** ώστε να χαρτογραφήσουμε το αρχείο στη μνήμη και στη συνέχεια να γράψουμε σε αυτό το χαρτογραφημένο χώρο. Με αυτόν τον τρόπο οι εγγραφές γίνονται σε μνήμη και δεν εμφανίζονται ως κανονικές κλήσεις write() στο strace.

Ένα παράδειγμα υλοποίησης:

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
#include <errno.h>

#define OFFSET      4096
#define DATA_SIZE   1024
#define FILE_SIZE   (OFFSET + DATA_SIZE)

int main(void) {
    char buf[DATA_SIZE];
    int fd;
    char *map;

    /* Γεμίζουμε τον πίνακα με τον χαρακτήρα 'd' */
    for (int i = 0; i < DATA_SIZE; i++) {
        buf[i] = 'd';
    }

    /* Άνοιγμα/δημιουργία του αρχείου "file" με O_CREAT | O_RDWR | O_TRUNC, με δικαιώματα S_IRWXU */
    fd = open("./file", O_CREAT | O_RDWR | O_TRUNC, S_IRWXU);
    if (fd < 0) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    /* Επέκταση του αρχείου στο μέγεθος FILE_SIZE (5120 bytes) */
    if (ftruncate(fd, FILE_SIZE) < 0) {
        perror("ftruncate");
        close(fd);
        exit(EXIT_FAILURE);
    }

    /* Χαρτογράφηση 1024 bytes του αρχείου από το offset 4096 με MAP_SHARED */
    map = mmap(NULL, DATA_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, OFFSET);
    if (map == MAP_FAILED) {
        perror("mmap");
        close(fd);
        exit(EXIT_FAILURE);
    }

    /* Αντιγραφή του buf στη χαρτογραφημένη περιοχή */
    memcpy(map, buf, DATA_SIZE);

    /* Καθαρισμός της χαρτογράφησης και κλείσιμο του αρχείου */
    if (munmap(map, DATA_SIZE) < 0) {
        perror("munmap");
    }
    close(fd);

    return 0;
}
```

**Επεξήγηση:**

- **Άνοιγμα/δημιουργία:** Το αρχείο ανοίγεται με open() σε λειτουργία read-write με δικαιώματα S_IRWXU.
- **ftruncate():** Ορίζει το μέγεθος του αρχείου στο FILE_SIZE (5120 bytes).
- **mmap():** Χαρτογραφεί ολόκληρο το αρχείο στη μνήμη με δικαιώματα ανάγνωσης και εγγραφής. Χρησιμοποιείται το MAP_SHARED ώστε οι αλλαγές να αντικατοπτρίζονται στο δίσκο.
- **memset():** Γράφει στον χαρτογραφημένο χώρο (στο offset 4096) 1024 bytes με τον χαρακτήρα 'd'.
- **msync():** Εξασφαλίζει ότι οι αλλαγές συγχρονίζονται με το αρχείο.
- Με αυτή τη μέθοδο οι εγγραφές γίνονται μέσω της μνήμης και δεν εμφανίζονται ως συνηθισμένες κλήσεις write() – κάτι που δυσκολεύει την παρακολούθηση μέσω strace.

---
