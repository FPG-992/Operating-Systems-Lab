**Θέμα 1 (40%)**

Εργάζεστε για την κατασκευή οδηγού συσκευής ενός συγκεκριμένου μοντέλου επιταχυντή ο οποίος μετατρέπει την αναπαράσταση ενός διανύσματος από πυκνή (dense) σε αραιή (sparse) μορφή και αντίστροφα, σε ΛΣ Linux. 

Ο οδηγός υλοποιεί μία συσκευή χαρακτήρων `/dev/conversion-vector`. Οι διεργασίες χώρου χρήστη επικοινωνούν με τη συσκευή μέσω κατάλληλων κλήσεων ioctl(). Συγκεκριμένα, οι λειτουργίες που υποστηρίζονται μέσω ioctl() είναι οι CONVERT_VECTOR και SET_CONVERSION.

Μέσω της CONVERT_VECTOR, οι διεργασίες στέλνουν στον επιταχυντή δεδομένα προς μετατροπή χρησιμοποιώντας ασύγχρονη λογική, δηλαδή η κλήση επιστρέφει όταν ολοκληρωθεί ο υπολογισμός μετατροπής της αναπαράστασης από τη συσκευή.

Η κλήση για τον υπολογισμό της μετατροπής από τον χρήστη πραγματοποιείται περνώντας ως όρισμα έναν περιγραφητή τύπου `struct cvec_descriptor`.

 Η συσκευή διαθέτει δομή απομονωτή (buffer) όπου αποθηκεύονται τα δεδομένα από τις κλήσεις ioctl() των διαφόρων διεργασιών. 
 
Κάθε slot του buffer διαθέτει ξεχωριστό πεδίο status που ενημερώνει τον οδηγό αν το slot
(i) είναι ελεύθερο (FREE)
(ii) δεσμευμένο αλλά δεν έχει επεξεργαστεί ακόμα (OCCUPIED)
(iii) αν έχει ήδη επεξεργαστεί από τον επιταχυντή (PROCESSED). 

Επίσης, κάθε slot διαθέτει ξεχωριστό πεδίο που ορίζει τον τύπο μετατροπής. Ο επιταχυντής επεξεργάζεται με τυχαίο τρόπο τα δεδομένα που βρίσκονται στον buffer (δηλαδή επεξεργάζεται τα slots που είναι σε κατάσταση OCCUPIED) και πραγματοποιεί μία διακοπή κάθε φορά που ολοκληρώνει έναν υπολογισμό. 

Αν δεν υπάρχει ελεύθερο slot στον buffer, τότε η διεργασία κοιμάται έως ότου ελευθερωθεί κάποιο slot. Όταν συμβεί αυτό, δεσμεύει ένα slot, στο οποίο τοποθετεί τον προς επεξεργασία περιγραφητή του, και κοιμάται έως ότου ο επιταχυντής ολοκληρώσει τον υπολογισμό, οπότε και ξυπνάει και επιστρέφει το αποτέλεσμα της πράξης πίσω στον χρήστη.

Μέσω της SET_CONVERSION, η κάθε διεργασία ορίζει αν οι κλήσεις μετατροπής που πραγματοποιεί η συγκεκριμένη διεργασία θα αφορούν την αναπαράσταση ενός διανύσματος από πυκνή (dense) σε αραιή (sparse) μορφή, ή το αντίστροφο. Η default τιμή αρχικοποίησης για κάθε διεργασία είναι η DENSE_TO_SPARSE.

**Σας δίνεται σκελετός αρχικής υλοποίησης του οδηγού. Επίσης, δίνονται οι παρακάτω βοηθητικές συναρτήσεις οι οποίες απαιτούν τη χρήση κατάλληλου συγχρονισμού κατά την κλήση τους:**

- **`int get_free_slot(struct cvec_device *cvdev);`**  
  Ψάχνει στον buffer για ένα διαθέσιμο slot και επιστρέφει τη θέση του αν υπάρχει κάποιο, αλλιώς -1.

- **`int get_processed_slot(struct cvec_device *cvdev);`**  
  Επιστρέφει τη θέση του τελευταίου slot που μόλις επεξεργάστηκε από τον επιταχυντή.

```c
#define DENSE_TO_SPARSE 0
#define SPARSE_TO_DENSE 1

struct cvec_state {
    ...locktype... lock;
    int conversion_mode;
};

struct cvec_descriptor {
    int len;        // the length of the arrays
    int *input;
    int *output;
};

struct cvec_device {
    #define BUF_LEN 1024
    struct {
        cvec_descriptor *cvdesc;
        int conversion_mode;
        int status;  // value can be FREE or OCCUPIED or PROCESSED
    } buffer[BUF_LEN];

    ...locktype... lock;
    wait_queue_head_t wq;
} cvec_dev;

void open(struct inode *inode, struct file *filp) {
    int ret = 0;
    struct cvec_state *state;
    struct cvec_device *cvdev = &cvec_dev;

    if ((ret = nonseekable_open(inode, filp)) < 0) {
        ret = -ENODEV;
        goto out;
    }

    state = kmalloc(sizeof(struct cvec_state), GFP_KERNEL);
    ... ??? ...

    return ret;

out:
    return ret;
}
```

```c
void intr(unsigned int intr_mask)
{
    struct cvec_device *cvdev = &cvec_dev;
    ...

    ... lock? ...
    ... ??? ...
    ... unlock? ...
    ...
}

static ssize_t cvec_ioctl(struct file *filp, unsigned int cmd,
                          unsigned long uarg)
{
    struct cvec_device *cvdev = &cvec_dev;
    struct cvec_descriptor *cvdesc;
    ...
    switch (cmd) {
    case CONVERT_VECTOR:
        cvdesc = kzalloc(sizeof(*cvdesc), GFP_KERNEL);
        ... initialize structs & copy data from user space ...
        ... check if there is a free slot in the buffer, otherwise sleep ...
        ... submit the computation and sleep until it finishes ...
        ... copy data to user space ...
        ... update the buffer ...
        ...
        break;
    case SET_CONVERSION:
        ... change conversion mode ...
        ...
        break;
    default:
        ret = -EINVAL;
        break;
    }
    return ret;
}
```

**Ζητούνται τα εξής:**

i. (10%) Υλοποιήστε την `cvec_open()`, συμπληρώνοντας τον σκελετό.

ii. (15%) Υλοποιήστε την `cvec_ioctl()`, συμπληρώνοντας τον σκελετό.

iii. (9%) Υλοποιήστε την συνάρτηση χειρισμού διακοπών `intr()` που προκαλεί ο επιταχυντής αφού ολοκληρώσει έναν υπολογισμό, συμπληρώνοντας τον σκελετό.

iv. (6%) Κάνετε χρήση των πεδίων `lock` στις δομές `cvec_state` και `cvec_device`. Αν ναι, ποιος ο ρόλος τους;

---

**Additional Instructions:**
If needed, you may add new fields to the structures or new functions to the code, as long as you describe their functionality accurately.

---

**Θέμα 2 (30%)**

Στοχεύουμε τώρα στην υποστήριξη της συσκευής `/dev/conversion-vector` σε περιβάλλον εικονικών μηχανών και αποφασίζουμε την υλοποίηση του οδηγού συσκευής στο QEMU/KVM σε ΛΣ Linux με χρήση του VirtIO split-driver model (frontend/backend).

Για το σκοπό αυτή, η δομή `cvec_device` τροποποιείται κατάλληλα: επεκτείνεται αντίστοιχα με τη χρήση μιας virtqueue δομής ενώ αφαιρείται η waitqueue αφού η επικοινωνία μέσω frontend και backend πραγματοποιείται με σύγχρονη (busy-wait) λογική. Επίσης, η υλοποίηση της `cvec_ioctl` τροποποιείται κατάλληλα. Σας δίνεται σκελετός του frontend μέρους, όπως εκτελείται στο χώρο πυρήνα του guest:

```c
struct cvec_device {
    #define BUF_LEN 1024
    struct {
        cvec_descriptor *cvdesc;
        int conversion_mode;
        int status;  // value can be FREE or OCCUPIED or PROCESSED
    } buffer[BUF_LEN];

    ...locktype... lock;

    struct virtqueue *vq;
} cvec_dev;

static ssize_t cvec_ioctl(struct file *filp, unsigned int cmd,
                          unsigned long uarg)
{
    struct scatterlist conversion_mode_sg, len_sg, input_sg, output_sg, *sgs[4];
    struct cvec_device *cvdev = &cvec_dev;
    struct cvec_descriptor *cvdesc;
    ...
    switch (cmd) {
    case CONVERT_VECTOR:
        cvdesc = kzalloc(sizeof(*cvdesc), GFP_KERNEL);
        // assume that copy data from user space has been properly implemented here
        // ...
        // so that cpdesc->len, cpdesc->input, cpdesc->output are properly initialized
        // no need to write the copy data from user part

        ... initialize sgs ...
        sg_init_one(&conversion_mode_sg, filp->private_data->conversion_mode,
                    sizeof(int));
        sgs[0] = &conversion_mode_sg;
        sg_init_one(&len_sg, cvdesc->len, sizeof(cvdesc->len));
        sgs[1] = &len_sg;
        sg_init_one(&input_sg, cvdesc->input, cvdesc->len);
        sgs[2] = &input_sg;
        sg_init_one(&output_sg, cvdesc->output, cvdesc->len);
        sgs[3] = &output_sg;

        ... send sgs and notify the host ...
        ...
        ... wait until the host completes the conversion ...
        ...
    }
}
```

```c
...
// assume that copy data to user space has been properly implemented
// no need to write the copy data to user part

break;
case SET_CONVERSION:
    ... // not needed to implement here
    break;
default:
    ret = -EINVAL;
    break;
}
return ret;
```

**Ακολουθεί η συνάρτηση χειρισμού στην πλευρά του host:**

```c
void vq_callback(VirtIODevice *vdev, VirtQueue *vq)
{
    VirtQueueElement elem;
    int *conversion_mode;
    int *len;
    int *input;
    int *output;

    if (!virtqueue_pop(vq, &elem))
        return;

    conversion_mode = elem.out_sg[0].iov_base;
    len = elem.out_sg[1].iov_base;
    input = elem.out_sg[2].iov_base;
    output = elem.in_sg[0].iov_base;

    ...
    *output = ... ;
    ...

    virtqueue_push(vq, &elem, 0);
    virtio_notify(vdev, vq);
}
```

**Ζητούνται τα εξής:**

i. (12%) Συμπληρώστε τον κώδικα που λείπει από την `cvec_ioctl()` ανάμεσα στις γραμμές 42 και 46, συμπληρώνοντας τον σκελετό. Σε αυτή την άσκηση δεν χρειάζεται να ασχοληθείτε με το κομμάτι που κάνει την αντιγραφή δεδομένων από και προς το χώρο χρήστη.

ii. (12%) Υλοποιήστε την `vq_callback()`, συμπληρώνοντας τον σκελετό.

iii. (6%) Είναι απαραίτητη η κλήση της `virtio_notify()` στη συγκεκριμένη περίπτωση και γιατί;

---

**Θέμα 3 (30%)**

**α. (8%) Εκτελέστε τις ακόλουθες εντολές στο φλοιό του Linux.**

```bash
# mount /dev/sda1 /fs1
# mount /dev/sda2 /fs2
# ln /fs1/foo /fs2/bar
```

Τι περιμένετε να επιστρέψει η κλήση της 1η; Γιατί συμβαίνει αυτό;

---

**β. (10%) Εκτελέστε τις ακόλουθες εντολές στο φλοιό του Linux.**

```bash
# ps | grep init
```

i. Περιγράψτε τι κάνουν οι παραπάνω εντολές.  
ii. Ποια system calls θα χρησιμοποιήσει το shell όταν τις εκτελέσει; Πόσες διεργασίες θα δημιουργηθούν; Πώς επικοινωνούν μεταξύ τους;

---

**γ. (12%) Δίνεται το παρακάτω πρόγραμμα:**

```c
1  int main (int argc, char *argv[]) {
2      char *buf;
3      int fd = open("./file", O_CREAT | O_RDWR | O_TRUNC, S_IRWXU);
4      ftruncate(fd, 1024);
5      buf = mmap(NULL, 1024, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
6      memset(buf, 1, 1024);
7      lseek(fd, 4096, SEEK_SET);
8      if (!fork()) {
9          char rbuf[1024];
10         fd = open("./file", O_RDONLY);
11         read(fd, rbuf, 1024);
12     }
13 }
```

i. Τι κάνει το παραπάνω πρόγραμμα; Ποιο είναι το return value της `read()` και ποια τα contents του `rbuf`;  
ii. Τι θα γινόταν αν κάναμε comment out την γραμμή 10;  
iii. Θα άλλαζε κάτι αν αντί για `MAP_SHARED` χρησιμοποιούσαμε `MAP_PRIVATE`;

---
