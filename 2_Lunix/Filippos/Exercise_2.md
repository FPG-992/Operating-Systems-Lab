### **Στόχος της Άσκησης**

- **Υλοποίηση ενός οδηγού συσκευής χαρακτήρων (Character Device Driver)** για ένα ασύρματο δίκτυο αισθητήρων στο λειτουργικό σύστημα Linux.
- **Διάθεση των δεδομένων μετρήσεων** από τους αισθητήρες σε διαφορετικά ειδικά αρχεία συσκευών, ανά αισθητήρα και τύπο μέτρησης.

### **Αρχιτεκτονική του Συστήματος**

- **Ασύρματο Δίκτυο Αισθητήρων**: Αισθητήρες που μετρούν τάση μπαταρίας, θερμοκρασία και φωτεινότητα.
- **Σταθμός Βάσης**: Συνδέεται μέσω USB με το Linux PC και εμφανίζει τα δεδομένα στη συσκευή `/dev/ttyUSB1`.

### **Ζητούμενα της Άσκησης**

1. **Υλοποίηση του Οδηγού Συσκευής Χαρακτήρων (Τμήμα (g))**:

   - **Δημιουργία ειδικών αρχείων συσκευών** για κάθε αισθητήρα και τύπο μέτρησης, π.χ., `/dev/lunix0-batt`, `/dev/lunix0-temp`, `/dev/lunix0-light`.
   - **Υποστήριξη των κλήσεων συστήματος**: `open()`, `read()`, `release()` κ.λπ.
   - **Διαχείριση πολλαπλών διεργασιών**: Υποστήριξη ταυτόχρονης πρόσβασης από πολλές διεργασίες με χρήση κατάλληλων μηχανισμών συγχρονισμού (κλειδώματα).
   - **Μπλοκάρισμα διεργασιών**: Όταν δεν υπάρχουν νέα δεδομένα, οι διεργασίες πρέπει να κοιμούνται και να ξυπνούν όταν γίνονται διαθέσιμες νέες μετρήσεις.
   - **Στάδια Υλοποίησης**:
     - **(g1) Πρώτο Στάδιο**:
       - Υλοποίηση των βασικών κλήσεων συστήματος.
       - Επιστροφή προκαθορισμένων (πλασματικών) τιμών στις κλήσεις `read()`.
       - Δεν απαιτείται κοιμισμός των διεργασιών.
     - **(g2) Δεύτερο Στάδιο**:
       - Ενσωμάτωση με το υπάρχον τμήμα (f) για λήψη πραγματικών δεδομένων.
       - Υλοποίηση μηχανισμών συγχρονισμού και μπλοκαρίσματος διεργασιών.

2. **Έλεγχος της Σωστής Λειτουργίας (Τμήμα (h))**:

   - **Ανάπτυξη προγράμματος χρήστη** που θα διαβάζει δεδομένα από τις νέες συσκευές και θα επαληθεύει τη σωστή λειτουργία του οδηγού.
   - **Δοκιμή πολλαπλών διεργασιών**: Βεβαιωθείτε ότι ο οδηγός διαχειρίζεται σωστά την ταυτόχρονη πρόσβαση.

3. **Προαιρετικά**:

   - **Υποστήριξη της κλήσης συστήματος `mmap()`** για ανάκτηση των μετρήσεων χωρίς κλήσεις συστήματος, μέσω απεικόνισης μνήμης (memory-mapped I/O).

### **Βήματα που Πρέπει να Ακολουθήσετε**

1. **Προετοιμασία του Περιβάλλοντος Ανάπτυξης**:

   - **Εγκατάσταση της εικονικής μηχανής (utopia VM)** που σας παρέχεται.
   - **Μεταγλώττιση και Εγκατάσταση του Linux Kernel 6.11** μέσα στην εικονική μηχανή, καθώς ο κώδικας του module που σας δίνεται είναι για αυτήν την έκδοση.
     - **Βήματα**:
       - Κατεβάστε τον πηγαίο κώδικα του Linux Kernel 6.11.
       - Μεταγλωττίστε τον πυρήνα μέσα στην εικονική μηχανή.
       - Εγκαταστήστε τον νέο πυρήνα και επανεκκινήστε την εικονική μηχανή για να φορτωθεί.

2. **Κατανόηση του Παρεχόμενου Κώδικα**:

   - **Μελετήστε τον κώδικα που σας δίνεται** για τα τμήματα (b), (c), (d), (e), (f).
   - **Κατανοήστε τις δομές δεδομένων και τα interfaces** που θα χρησιμοποιήσετε.

3. **Υλοποίηση του Οδηγού Συσκευής Χαρακτήρων (Τμήμα (g))**:

   - **Στάδιο (g1): Βασική Υλοποίηση**:
     - **Δημιουργήστε τη δομή `file_operations`** με τις κατάλληλες μεθόδους (`open`, `read`, `release`).
     - **Υλοποιήστε τις βασικές λειτουργίες**:
       - `lunix_chrdev_open()`: Διαχείριση ανοίγματος συσκευής.
       - `lunix_chrdev_read()`: Επιστροφή προκαθορισμένων τιμών.
       - `lunix_chrdev_release()`: Καθαρισμός πόρων κατά το κλείσιμο.
     - **Δημιουργήστε τα ειδικά αρχεία συσκευών** χρησιμοποιώντας το script `mk-lunix-devs.sh`.

   - **Στάδιο (g2): Ενσωμάτωση με το Υπάρχον Σύστημα**:
     - **Επικοινωνήστε με τα `sensor buffers`** για να λάβετε πραγματικά δεδομένα.
     - **Υλοποιήστε μηχανισμούς συγχρονισμού** (π.χ., semaphores, spinlocks) για ασφαλή πρόσβαση στα δεδομένα.
     - **Υλοποιήστε το μπλοκάρισμα διεργασιών** όταν δεν υπάρχουν νέα δεδομένα, χρησιμοποιώντας ουρές αναμονής (`wait queues`).

4. **Έλεγχος και Δοκιμή του Οδηγού (Τμήμα (h))**:

   - **Μεταγλώττιση και Φόρτωση του Module**:
     - Χρησιμοποιήστε το `Makefile` που σας παρέχεται για τη μεταγλώττιση.
     - Φορτώστε το module με `insmod` και επαληθεύστε ότι φορτώθηκε σωστά με `lsmod`.

   - **Έλεγχος Λειτουργίας**:
     - **Δοκιμάστε την ανάγνωση δεδομένων** από τα ειδικά αρχεία συσκευών με την εντολή `cat` ή γράφοντας ένα πρόγραμμα χρήστη.
     - **Δοκιμάστε πολλαπλές διεργασίες** που διαβάζουν ταυτόχρονα από την ίδια συσκευή.
     - **Επαληθεύστε το μπλοκάρισμα διεργασιών** όταν δεν υπάρχουν νέα δεδομένα.

5. **Προαιρετική Υλοποίηση**:

   - **Υποστήριξη `mmap()`**:
     - Υλοποιήστε την κλήση συστήματος `mmap()` στον οδηγό σας.
     - **Επιτρέψτε στο πρόγραμμα χρήστη** να χαρτογραφήσει τους `sensor buffers` στη μνήμη του.

### **Συμβουλές και Προτάσεις**

- **Μελετήστε τον κώδικα του `scull`** (Simple Character Utility for Loading Localities) από το βιβλίο “Linux Device Drivers” για παραδείγματα.
- **Χρησιμοποιήστε τα εργαλεία debugging**:
  - `printk()` για εκτύπωση μηνυμάτων στον πυρήνα.
  - `dmesg` για ανάγνωση των μηνυμάτων του πυρήνα.
- **Προσέξτε τις ιδιαιτερότητες του kernel programming**:
  - **Μην χρησιμοποιείτε λειτουργίες που μπορούν να κοιμηθούν** σε context διακοπών.
  - **Χρησιμοποιήστε τις κατάλληλες συναρτήσεις** για πρόσβαση σε δεδομένα χώρου χρήστη (`copy_to_user`, `copy_from_user`).
- **Διαβάστε προσεκτικά τον οδηγό υλοποίησης** που σας παρέχεται, καθώς περιέχει σημαντικές πληροφορίες για τα θέματα συγχρονισμού και διαχείρισης μνήμης.

### **Τελικός Σκοπός**

- **Ανάπτυξη ενός πλήρως λειτουργικού οδηγού συσκευής** που επιτρέπει την ανάκτηση των μετρήσεων από τους αισθητήρες μέσω ξεχωριστών ειδικών αρχείων.
- **Κατανόηση της λειτουργίας των οδηγών συσκευών στο Linux** και της επικοινωνίας χώρου χρήστη-πυρήνα.
