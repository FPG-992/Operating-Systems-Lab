### Αρχιτεκτονική συστήματος ασύρματου δικτύου αισθητήρων

Αντικείμενο της εργαστηριακής άσκησης είναι η υλοποίηση ενός οδηγού συσκευής για ένα ασύρματο δίκτυο αισθητήρων κάτω από το λειτουργικό σύστημα Linux. Το ασύρματο δίκτυο με το οποίο θα εργαστείτε διαθέτει έναν αριθμό από αισθητήρες (ασύρματες κάρτες Crossbow MPR2400CA με αισθητήρες τάσης, θερμοκρασίας και φωτεινότητας MDA100CB) και ένα σταθμό βάσης (κάρτα MPR2400CA και διασύνδεση USB MIB520CB). Ο σταθμός βάσης συνδέεται μέσω USB με υπολογιστικό σύστημα Linux στο οποίο και θα εκτελείται ο ζητούμενος οδηγός συσκευής.

Οι αισθητήρες αναφέρουν περιοδικά το αποτέλεσμα τριών διαφορετικών μετρήσεων: της τάσης της μπαταρίας που τους τροφοδοτεί, της θερμοκρασίας και της φωτεινότητας του χώρου όπου βρίσκονται. Οι αισθητήρες οργανώνονται σε ένα πλέγμα (mesh), έτσι ώστε τα δεδομένα τους να μεταφέρονται από εναλλακτικές διαδρομές και το δίκτυο να προσαρμόζεται αυτόματα στην περίπτωση όπου ένας ή περισσότεροι αισθητήρες είναι εκτός της εμβέλειας του σταθμού βάσης (Σχήμα 2).

Ο σταθμός βάσης λαμβάνει πακέτα με δεδομένα μετρήσεων, τα οποία προωθεί μέσω διασύνδεσης USB στο υπολογιστικό σύστημα. Η διασύνδεση υλοποιείται με κύκλωμα Serial over USB, με το τσιπ FTDI FT2232C για το οποίο ο πυρήνας διαθέτει ενσωματωμένους οδηγούς.

Στην περίπτωση αυτή, δε γίνεται καμία διάκριση ανάμεσα στα διαφορετικά πακέτα δεδομένων: τα δεδομένα όλων των μετρήσεων όλων των αισθητήρων εμφανίζονται σε μία εικονική σειριακή θύρα, π.χ., /dev/ttyUSB1.

Επιπλέον, δεν υποστηρίζεται ταυτόχρονη πρόσβαση από πολλές διαφορετικές διεργασίες· μόνο μία έχει νόημα να ανοίγει κάθε φορά την εικονική σειριακή θύρα.

Χρειάζεται λοιπόν η ανάπτυξη ενός οδηγού συσκευής ο οποίος να προσφέρει κατάλληλο μηχανισμό, αντιμετωπίζοντας ανεξάρτητα τους αισθητήρες και τα μετρούμενα μεγέθη, επιτρέποντας ταυτόχρονη πρόσβαση στα εισερχόμενα δεδομένα και κάνοντας δυνατή την επιβολή διαφορετικής πολιτικής από το διαχειριστή του συστήματος όσον αφορά την πρόσβαση σε αυτά.

### Lunix:TNG

Όπως και οι υπόλοιποι οδηγοί, έτσι και το Lunix:TNG θα χρησιμοποιήσει ένα συγκεκριμένο major number. Ωστόσο, η επιλογή δεν μπορεί να γίνει αυθαίρετα, εφόσον πολλοί χρησιμοποιούνται ήδη. Στο αρχείο Documentation/devices.txt στον κώδικα του πυρήνα, κάτω από τον κατάλογο /usr/src/linux, υπάρχει μια λίστα με την τρέχουσα αντιστοιχία. Ορισμένοι αριθμοί είναι δεσμευμένοι για πειραματική χρήση, όπως ο 60, τον οποίο προτείνεται να χρησιμοποιήσετε. Οι αριθμοί που χρησιμοποιούνται κάθε στιγμή από τον πυρήνα φαίνονται με χρήση της εντολής cat /proc/devices.

Τα ειδικά αρχεία κατασκευάζονται με χρήση της εντολής mknod, οπότε καθορίζεται το είδος τους (character ή block node) και οι major/minor numbers που τους αντιστοιχούν. Το Lunix:TNG θα χρησιμοποιεί περισσότερα του ενός ειδικά αρχεία, ένα για κάθε αισθητήρα του δικτύου και είδος μέτρησης που υποστηρίζεται. Σε κάθε ζεύγος {αριθμός αισθητήρα, μέτρηση} χρειάζεται να ανατεθεί συγκεκριμένο όνομα αρχείου και αντίστοιχος minor number. Προτείνεται τα 3 λιγότερο σημαντικά bits κάθε minor number να καθορίζουν το είδος της μέτρησης [οι μετρήσεις αριθμούνται με τη σειρά «τάση μπαταρίας = 0, θερμοκρασία, φωτεινότητα» και υπάρχει χώρος για το πολύ 8 μετρήσεις ανά αισθητήρα], ενώ τα υπόλοιπα τον αριθμό του αισθητήρα. Έτσι η τιμή του minor number προκύπτει ως minor = αισθητήρας * 8 + μέτρηση.

Το αρχείο /dev/lunix0-batt που αντιστοιχεί στην τάση της μπαταρίας του πρώτου αισθητήρα φτιάχνεται με την εντολή:

```bash
mknod /dev/lunix0-batt c 60 0
```

Ενώ το αρχείο /dev/lunix1-temp που αντιστοιχεί στη θερμοκρασία του δεύτερου θα είχε minor number 9. Σας δίνεται το script [mk-lunix-devs.sh](http://mk-lunix-devs.sh/), το οποίο κατασκευάζει αυτόματα τους ανάλογους κόμβους με βάση αυτή τη σύμβαση, για 16 αισθητήρες.

### Λειτουργικές απαιτήσεις οδηγού συσκευής

Ο ζητούμενος οδηγός συσκευής χρειάζεται να προσφέρει τη δυνατότητα χωριστής πρόσβασης ανά αισθητήρα και μετρούμενο μέγεθος μέσω διαφορετικών ειδικών αρχείων. Το πλήθος των απαιτούμενων αρχείων θα είναι ίσο με τον αριθμό των υποστηριζόμενων αισθητήρων επί τον αριθμό των υποστηριζόμενων μετρήσεων, που είναι τρεις: τάση μπαταρίας, θερμοκρασία, φωτεινότητα. Κάθε ζεύγος {αριθμός μετρητή, μέτρηση} θα αντιστοιχιστεί σε διαφορετικό ειδικό αρχείο, με διαφορετικό minor number.

Η πρώτη προσπάθεια ανάγνωσης από ειδικό αρχείο θα επιστρέφει έναν αριθμό από bytes που θα αναπαριστούν την πιο πρόσφατη τιμή του μετρούμενου μεγέθους, σε αναγνώσιμη μορφή, μορφοποιημένη ως δεκαδικό αριθμό.

Αν δεν έχουν ακόμη παραληφθεί δεδομένα για τη συγκεκριμένη μέτρηση, ή αν γίνουν επόμενες προσπάθειες ανάγνωσης, ο οδηγός θα πρέπει να κοιμίζει τη διεργασία έως ότου παραληφθούν νέα δεδομένα. Έτσι, αυτή δεν θα καταναλώνει χρόνο στην CPU του συστήματος. Οι δεκαδικές αναπαραστάσεις διαφορετικών μετρήσεων διαχωρίζονται με κενούς χαρακτήρες.

### Παράδειγμα χρήσης του ολοκληρωμένου οδηγού

Ο απλός χρήστης “user”, αφού κάνει login μεταγλωττίζει τον κώδικα του module δίνοντας την εντολή make:

[αν ο πηγαίος κώδικας του πυρήνα για τον οποίο γίνεται η μεταγλώττιση είναι σε ασυνήθιστη θέση, χρειάζεται να τεθεί η μεταβλητή περιβάλλοντος KERNELDIR]

```bash
user@machine:~/lunix-tng$ export KERNELDIR=/usr/src/linux-headers6.11
user@machine:~/lunix-tng$ make
```

```bash
gcc -Wall -Werror -o mk-lunix-lookup mk-lunix-lookup.c -lm
./mk-lunix-lookup >lunix-lookup.h
make -C /usr/src/linux-headers-6.11 M=/home/user/lunix-tng modules
make[1]: Entering directory '/usr/src/linux-headers-6.11'
	CC [M] /home/user/lunix-tng/lunix-module.o
	CC [M] /home/user/lunix-tng/lunix-chrdev.o
	CC [M] /home/user/lunix-tng/lunix-ldisc.o
	CC [M] /home/user/lunix-tng/lunix-protocol.o
	CC [M] /home/user/lunix-tng/lunix-sensors.o
	LD [M] /home/user/lunix-tng/lunix.o
	MODPOST /home/user/lunix-tng/Module.symvers
	CC [M] /home/user/lunix-tng/lunix.mod.o
	LD [M] /home/user/lunix-tng/lunix.ko
make[1]: Leaving directory '/usr/src/linux-headers-6.11'
gcc -Wall -Werror -o lunix-attach lunix-attach.c
```

Στη συνέχεια, αποκτά δικαιώματα διαχειριστή (su), για να φορτώσει το module (insmod), να δημιουργήσει μια σειρά από ειδικά αρχεία της συσκευής ([mk-lunixdevs.sh](http://mk-lunixdevs.sh/)) και να ενεργοποιήσει την είσοδο δεδομένων από τη σειριακή θύρα USB /dev/ttyUSB1 (με lunix-attach), όπου υποθέτουμε ότι είναι συνδεδεμένος ο σταθμός βάσης του ασύρματου δικτύου αισθητήρων.

```bash
user@machine:~/lunix-tng$ su –
Password:
```

```bash
machine:~# cd ~user/lunix-tng
machine:/home/user/lunix-tng# insmod ./lunix.ko
machine:/home/user/lunix-tng# ./mk-lunix-devs.sh
machine:/home/user/lunix-tng# ./lunix-attach /dev/ttyUSB1
tty_open: looking for lock
tty_open: trying to open /dev/ttyUSB1
tty_open: /dev/ttyUSB1 (fd=3) Line discipline set on /dev/ttyUSB1,
press ^C to release the TTY...
```

Τέλος, ζητά τη θερμοκρασία του 3ου αισθητήρα.

```bash
user@machine:~$ cat /dev/lunix2-temp
[αν ο αισθητήρας είναι κλειστός, εδώ η cat φαίνεται να έχει κολλήσει]
 27.791 [μικρή παύση ανάμεσα σε κάθε μέτρηση, ανάλογα με τη συχνότητα ανανέωσης των
δεδομένων] 27.791 27.693 27.791 ^C
```

### Προτεινόμενη αρχιτεκτονική οδηγού συσκευής

Το σύστημα οργανώνεται σε δύο κύρια μέρη: Το πρώτο (τμήματα (c), (d), (e) του σχήματος) αναλαμβάνει τη συλλογή των δεδομένων από το σταθμό βάσης και την επεξεργασία τους με συγκεκριμένο πρωτόκολλο, έτσι ώστε να εξαχθούν οι τιμές των μετρούμενων μεγεθών, οι οποίες και κρατούνται σε κατάλληλες δομές προσωρινής αποθήκευσης (buffers) στη μνήμη (τμήμα (f)). Το δεύτερο (τμήματα (g), (h)), αναλαμβάνει την εξαγωγή των δεδομένων στο χώρο χρήστη, υλοποιώντας μια σειρά από συσκευές χαρακτήρων. Τα δεδομένα προέρχονται από ανάγνωση των χώρων ενδιάμεσης αποθήκευσης.

Το τελικό σύστημα θα λειτουργεί ως εξής: Τα δεδομένα των μετρήσεων αφού (a) λαμβάνονται από το σταθμό βάσης (b) θα προωθούνται μέσω USB στο υπολογιστικό σύστημα. Στη συνέχεια όμως δεν θα ακολουθούν τη συνήθη πορεία τους, π.χ., προς το /dev/ttyUSB1 αλλά (c) θα παραλαμβάνονται από ένα φίλτρο, τη διάταξη γραμμής (line discipline) του Lunix, η οποία (d) θα τα προωθεί σε κατάλληλο στρώμα ερμηνείας του πρωτοκόλλου των αισθητήρων (e). Το τμήμα αυτό ερμηνεύει το περιεχόμενο των πακέτων και αποθηκεύει τα δεδομένα των μετρήσεων σε διαφορετικούς buffers ανά αισθητήρα (f). Η ζητούμενη συσκευή χαρακτήρων (g), αναλόγως με το ποιο ειδικό αρχείο χρησιμοποιεί η εφαρμογή χρήστη, θα επιτρέπει την ανάκτηση (h) από τους buffers των δεδομένων που αντιστοιχούν σε κάθε περίπτωση.

Η υλοποίηση των τμημάτων (b), (c), (d), (e), (f) σας δίνεται έτοιμη, ως τμήματα κώδικα μαζί με τις κατάλληλες δομές δεδομένων που ορίζουν τις διεπαφές (interfaces) ανάμεσά τους. Από εσάς ζητείται η υλοποίηση του (g) και ο έλεγχος (h) της σωστής λειτουργίας του συστήματος, μέσω ενός προγράμματος χρήστη.

### Λειτουργίες αρχείου - Η δομή file_operations

Κάθε πεδίο της δομής αυτής αντιστοιχεί σε μία λειτουργία που αναλαμβάνει να επιτελέσει ο οδηγός συσκευής που υλοποιούμε, όταν του ζητηθεί από άλλα τμήματα του πυρήνα. Η συσκευή αναγνωρίζεται εσωτερικά στον πυρήνα μέσω της δομής file που προκύπτει από άνοιγμα ενός ειδικού αρχείου, π.χ., του /dev/sensor1-light από κάποια διεργασία.

```c
loff_t llseek (struct file *, loff_t, int);
```

Η μέθοδος llseek() χρησιμοποιείται για να αλλάξουμε την θέση ανάγνωσης / εγγραφής σε ένα αρχείο και η νέα τιμή επιστρέφεται ως μια θετική τιμή. Τα λάθη σηματοδοτούνται από αρνητική τιμή.

```c
ssize_t read(struct file *, char __user *, size_t, loff_t *);
```

Χρησιμοποιείται για να διαβάζει δεδομένα από τη συσκευή. Αν ο οδηγός συσκευής δεν υποστηρίζει αυτή τη λειτουργία, οπότε ο δείκτης στη θέση αυτή είναι NULL, η κλήση συστήματος read() αποτυγχάνει με την τιμή -EINVAL (“Invalid argument”). Μια μη αρνητική επιστρεφόμενη τιμή φανερώνει το πλήθος των bytes που διαβάστηκαν επιτυχώς, ενώ η τιμή 0 υποδηλώνει ότι η ανάγνωση έφτασε στο τέλος του αρχείου (EOF).

Η μέθοδος αυτή θα είναι η καρδιά της υλοποίησής σας. Χρειάζεται να λαμβάνει δεδομένα από τους sensor buffers, να φροντίζει για τη σωστή μορφοποίησή τους και να τα περνά στο χώρο χρήστη.

```c
ssize_t write(struct file *, const char __user *, size_t, loff_t *);
```

Στέλνει δεδομένα στην συσκευή. Αν δεν παρέχεται από τον οδηγό συσκευής, επιστρέφεται -EINVAL στο πρόγραμμα που κάλεσε την κλήση συστήματος write(). Η επιστρεφόμενη τιμή, αν δεν είναι αρνητική, φανερώνει το πλήθος των bytes που γράφτηκαν επιτυχώς.

```c
int unlocked_ioctl(struct file *, unsigned int, unsigned long);
```

Η κλήση συστήματος ioctl() προσφέρει ένα τρόπο για να δώσουμε ειδικές εντολές για τη συσκευή υλικού, που δεν είναι μπορούν να παρασταθούν ούτε ως ανάγνωση ούτε ως εγγραφή δεδομένων . Για παράδειγμα, μια τέτοια εντολή θα ήταν η μορφοποίηση της δισκέτας για τη συσκευή /dev/fd0, ή η μεταβολή του baud rate για μια σειριακή θύρα (/dev/ttyS0). Μερικές εντολές ioctl ικανοποιούνται άμεσα από τον πυρήνα, χωρίς να κληθεί ο οδηγός συσκευής.

```c
int open (struct inode *, struct file *)
```

Αν και αυτή η συνάρτηση είναι η πρώτη που καλείται στον κόμβο συσκευής, ο οδηγός συσκευής δεν χρειάζεται να ορίσει μια τέτοια μέθοδο. Στην περίπτωση αυτή το άνοιγμα συσκευής θεωρείται πάντα επιτυχές, αλλά ο οδηγός μας δεν ενημερώνεται ποτέ. Εμείς θα ορίσουμε τη συνάρτηση αυτή, επειδή θέλουμε να ενημερώνεται ο οδηγός μας για το άνοιγμα της συσκευής, ώστε να μας δίνεται η ευκαιρία να κάνουμε αρχικοποιήσεις σε δομές δεδομένων του οδηγού. Το όρισμα τύπου struct inode αφορά στο ειδικό αρχείο που χρησιμοποιήθηκε κατά την κλήση συστήματος

Με χρήση των μακροεντολών:

```c
unsigned int iminor(struct inode *inode);
unsigned int imajor(struct inode *inode);
```

μπορούμε να ανακτήσουμε τον major και minor number του αρχείου, ώστε το ανοιχτό αρχείο που θα προκύψει να αφορά συγκεκριμένο αισθητήρα και μέτρηση του δικτύου.

Στην περίπτωσή που εξετάζετε, η open οφείλει να δεσμεύει χώρο για τη δομή τύπου lunix_chrdev_state_struct που περιγράφει την τρέχουσα κατάσταση της συσκευής και να τη συνδέει με τη δομή file μέσω του δείκτη private_data.

```c
void (*release) (struct inode *, struct file *);
```

Αυτή η μέθοδος καλείται όταν μια διεργασία χρήστη εκτελέσει την κλήση συστήματος close() για το κλείσιμο του ανοιχτού αρχείου της συσκευής, οπότε καταστρέφεται η αντίστοιχη δομή file. Όμοια με την open(), δεν χρειάζεται να οριστεί μέθοδος release() και θα είναι πάντα επιτυχές το κλείσιμο. Στην δική μας περίπτωση, θα ορίζουμε συνάρτηση για το δείκτη release, για να ενημερωνόμαστε όταν το πρόγραμμα που είχε ανοίξει τη συσκευή μας κλείσει το ανοιχτό αρχείο και να απελευθερώνουμε τους αντίστοιχους πόρους (δεσμευμένη μνήμη).

Η μορφή της δομής file_operations για το Lunix:TNG θα είναι κάπως έτσι:

```c
static struct file_operations lunix_chrdev_fops =
{
 .owner = THIS_MODULE,
 .open = lunix_chrdev_open,
 .release = lunix_chrdev_release,
 .read = lunix_chrdev_read
};
```

### Ανοιχτά αρχεία - Η δομή file

Τα πεδία της δομής file αναπαριστούν την κατάσταση ενός αρχείου ανοιχτού για κάποια διεργασία χρήστη, δηλαδή τα δικαιώματα πρόσβασης της διεργασίας στο αρχείο, τη θέση του δείκτη ανάγνωσης / εγγραφής κλπ. Τα σημαντικότερα από αυτά είναι:

```c
mode_t f_mode;
```

Τα bits του πεδίου f_mode καθορίζουν το είδος της πρόσβασης που επιτρέπεται να έχει η διεργασία στο ανοιχτό αρχείο. Για παράδειγμα, αν το αρχείο έχει ανοιχτεί για ανάγνωση, το bit FMODE_READ θα είναι 1 και η παράσταση f_mode & FMODE_READ θα είναι μη μηδενική.

```c
loff_t f_pos;
```

Στο πεδίο αυτό αποθηκεύεται η τρέχουσα θέση του δείκτη ανάγνωσης / εγγραφής. Ο τύπος loff_t είναι μια τιμή εύρους 64bit (long long στην ορολογία του gcc). Ο οδηγός μπορεί να διαβάσει την τιμή αυτή αν χρειάζεται να μάθει την τρέχουσα θέση. Η μέθοδος llseek, εφόσον ορίζεται, αναλαμβάνει να ανανεώνει την τιμή f_pos. Οι μέθοδοι read και write πρέπει την ανανεώνουν όταν μεταφέρουν δεδομένα.

```c
unsigned short f_flags;
```

Τα flags αυτά καθορίζουν κάποιες άλλες ιδιότητες πρόσβασης, όπως O_RDONLY, O_NONBLOCK, και O_SYNC. Ένας οδηγός ελέγχει συνήθως για το flag για τις λειτουργίες nonblocking, ενώ τα άλλα σπάνια χρησιμοποιούνται.

```c
struct file_operations *f_op;
```

Αυτό είναι το πεδίο της δομής file που επιτρέπει την αντιστοίχιση του ανοιχτού αρχείου με συγκεκριμένη δομή file_operations, άρα και με συγκεκριμένο οδηγό συσκευής. Ο πυρήνας αρχικοποιεί τον δείκτη αυτό κατά το άνοιγμα και τον ακολουθεί όποτε χρειάζεται να καλέσει κάποια συνάρτηση για να εκτελέσει κάποια λειτουργία επάνω στο ανοιχτό αρχείο.

```c
void *private_data;
```

H κλήση συστήματος open() θέτει το δείκτη αυτό σε NULL πριν την κλήση της μεθόδου open του οδηγού. Ο οδηγός είναι ελεύθερος να κάνει χρήση του δείκτη αυτού όπως θεωρεί καλύτερο, ακόμα και να τον αγνοήσει εντελώς. Χρησιμοποιείται συνήθως ώστε να αντιστοιχιστεί το ανοιχτό αρχείο σε ιδιωτικές δομές δεδομένων του οδηγού συσκευής. Ο δείκτης μπορεί να χρησιμοποιηθεί ώστε να δείχνει σε δεσμευμένα δεδομένα, αλλά αυτά πρέπει να απελευθερωθούν από τη μέθοδο release πριν ο πυρήνας καταστρέψει τη δομή file. O δείκτης private_data είναι ένας πολύ χρήσιμος τρόπος για να κρατάμε πληροφορίες για την κατάσταση της συσκευής (state information) ανάμεσα στις διάφορες κλήσεις συστήματος.

Στην περίπτωσή που εξετάζετε, θα χρησιμοποιείται ώστε να δείχνει σε δομή τύπου lunix_chrdev_state_struct, η οποία περιγράφει την τρέχουσα κατάσταση της συσκευής.

### Η διάταξη γραμμής του Lunix:TNG

Ο απλούστερος τρόπος ώστε το υπό κατασκευή σύστημα να έχει πρόσβαση στα πακέτα αποστέλλονται από το σταθμό βάσης, είναι να κατασκευαστεί μια νέα διάταξη γραμμής, η “Lunix:TNG line discipline”, η οποία θα συλλαμβάνει τα δεδομένα εισόδου και θα τα προωθεί όχι απευθείας στο χώρο χρήστη αλλά σε κατάλληλο τμήμα επεξεργασίας του πρωτοκόλλου των αισθητήρων, το οποίο και θα εξάγει τις τιμές των μετρούμενων μεγεθών.

Η διάταξη αυτή έχει ήδη υλοποιηθεί, ο κώδικάς της σας δίνεται στα αρχεία lunixldisc.h και lunix-ldisc.c. 

### Επεξεργασία των πακέτων και εξαγωγή μετρήσεων

Το τμήμα επεξεργασίας του πρωτοκόλλου επικοινωνίας των αισθητήρων του δικτύου υλοποιείται στα αρχεία lunix-protocol.h και lunix-protocol.c που σας δίνονται. Η επεξεργασία των πακέτων βασίζεται σε μία απλή μηχανή καταστάσεων, η οποία γνωρίζει πόσα bytes δεδομένων χρειάζεται να περιμένει σε κάθε φάση της επεξεργασίας, έως ότου συμπληρωθεί ένα πλήρες πακέτο μετρήσεων.

Οι εισερχόμενοι χαρακτήρες παρέχονται στον κώδικα επεξεργασίας του πρωτοκόλλου μέσω της lunix_protocol_received_buf() που καλείται από τη lunix_ldisc_receive_buf(). Οι τιμές των μετρούμενων μεγεθών εξάγονται ως αριθμητικές ποσότητες των 16 bit χωρίς πρόσημο (τύπος uint16_t της C) και αποθηκεύονται σε χώρους προσωρινής απ.οθήκευσης.

Οι ποσότητες αυτές χρειάζεται να μετατραπούν με βάση συγκεκριμένες συναρτήσεις που δίνονται από τον κατασκευαστή των αισθητήρων έτσι ώστε να εξαχθούν προσημασμένες δεκαδικές τιμές κατάλληλες για παρουσίαση και καταγραφή. Η μετατροπή αυτή χρειάζεται λειτουργίες κινητής υποδιαστολής, για παράδειγμα διαίρεση, πολλαπλασιασμό και υπολογισμό λογαρίθμων για ποσότητες τύπου float. Ωστόσο, η σχεδίαση του πυρήνα του Linux καθιστά απαγορευτική την εκτέλεση πράξεων κινητής υποδιαστολής από κώδικα του kernelspace. Οι λόγοι είναι κυρίως δύο:

- Η κατάσταση της μονάδας εκτέλεσης υπολογισμών κινητής υποδιαστολής (Floating Point Unit – FPU) δε σώζεται και δεν επαναφέρεται όταν ο επεξεργαστής περνά από την εκτέλεση χώρου χρήστη στην εκτέλεση χώρου πυρήνα. Έτσι, αν ο πυρήνας αλλάξει την τιμή καταχωρητών της είναι σχεδόν σίγουρο ότι θα επηρεαστεί η ορθότητα της εκτέλεσης προγραμμάτων χρήστη.
- Ορισμένες από τις αρχιτεκτονικές στις οποίες έχει μεταφερθεί ο πυρήνας (π.χ., η αρχική αρχιτεκτονική i386 και η αρχιτεκτονική ARM) δεν υποστηρίζουν καν εντολές κινητής υποδιαστολής στο υλικό, αλλά αυτές αναλαμβάνονται από βιβλιοθήκες που τις υλοποιούν μέσω πράξεων ακεραίων, οι οποίες δε συμπεριλαμβάνονται στον πυρήνα.

Για το προβλημα αυτό έχουμε υλοποιήσει την εξής λύση: 

- Εφόσον με 16 bits κωδικοποιούνται το πολύ 65536 καταστάσεις, μπορεί η απεικόνιση των τιμών αυτών σε αναγνώσιμες τιμές να υπολογιστεί εκ των προτέρων σε πίνακες αναζήτησης (lookup tables). Μια δεκαδική τιμή σταθερής ακρίβειας, της μορφής ±xx.yyy μπορεί να αποθηκεύεται ως ο ακέραιος ±xxyyyy, οπότε χρειάζεται απλά μια διαίρεση και μια πράξη υπολοίπου για τον υπολογισμό του δεκαδικού και του ακέραιου μέρους της.

Σας δίνεται κώδικας που υλοποιεί τη λύση. Το πρόγραμμα mk-lunixlookup.c περιέχει τις κατάλληλες συναρτήσεις ώστε να υπολογίσει τις απεικονίσεις όλου του εύρους μη προσημασμένων τιμών από 0x0000 έως 0xFFFF και για τρία μετρούμενα μεγέθη. Το αποτέλεσμα αποθηκεύεται σε τρεις πίνακες αναζήτησης, στο αρχείο lunix-lookup.h.

### Ανάγνωση 16-bit και 32-bit τιμών από συσκευές υλικού

Τα πακέτα που προέρχονται από το σταθμό βάσης είναι κωδικοποιημένα σε little-endian μορφή. Εφόσον δεν είναι δυνατό να γνωρίζουμε τη μορφή του συγκεκριμένου επεξεργαστή όπου εκτελείται ο κώδικας του οδηγού, χρειάζεται κάθε φορά που γίνεται επεξεργασία των εισερχόμενων δεδομένων να μετατρέπονται από little-endian στη φυσική μορφή του συστήματος (αν αυτό είναι little-endian δε γίνεται καμία μετατροπή). Για το σκοπό αυτό ο πυρήνας προσφέρει μια σειρά μακροεντολών, όπως οι cpu_to_le32() και le32_to_cpu().

### Πρόσβαση σε δεδομένα χώρου χρήστη

Η υλοποίηση της λειτουργίας read() που θα κατασκευάσετε, χρειάζεται να αντιγράφει δεδομένα προς απομονωτές χώρου χρήστη, ώστε να επιστρέφει τα δεδομένα που ζητήθηκαν από τη διεργασία. Εφόσον ο πυρήνας έχει απεριόριστη πρόσβαση στη μνήμη, θεωρεί αναξιόπιστο κάθε δεδομένο που παρέχει η διεργασία και πρέπει να ελέγχει όλες τις διευθύνσεις που αυτή περνά ως ορίσματα.

Για την πρόσβαση σε απομονωτές χώρου χρήστη ο πυρήνας προσφέρει δύο ειδικές διαδικασίες, τις copy_from_user() και copy_to_user() οι οποίες αντικαθιστούν την memcpy() και κάνουν ασφαλή αντιγραφή δεδομένων. Επιστρέφουν τον αριθμό των bytes που δεν μπόρεσαν να αντιγράψουν. Αν αυτός είναι μη μηδενικός, σημαίνει ότι η διεργασία προσπάθησε να κάνει πρόσβαση εκτός ορίων με δείκτη που είχε μη επιτρεπτή τιμή. Στην περίπτωση αυτή επιστρέφεται κατάλληλος κωδικός λάθους που τελικά καταλήγει στην αποστολή ενός σήματος “Segmentation Fault”:

```c
if (copy_to_user(usrbuf, kernel_addr, cnt)) {
	return -EFAULT;
}
```

### Μπλοκάρισμα/επανεκκίνηση διεργασιών

Ένα από τα σημαντικότερα προβλήματα που έχει να αντιμετωπίσει ο οδηγός συσκευής χαρακτήρων σας είναι τι θα συμβαίνει όταν δεν υπάρχουν νέα διαθέσιμα δεδομένα μετρήσεων και κάποια διεργασία εκτελέσει την κλήση συστήματος read(). Στην περίπτωση αυτή, θα πρέπει ο οδηγός να κοιμίζει τη διεργασία: αυτό σημαίνει ότι η διεργασία αλλάζει κατάσταση, δεν είναι πλέον «έτοιμη» προς εκτέλεση και ο χρονοδρομολογητής θα διαλέξει κάποια άλλη να εκτελεστεί στη θέση της. Ενώ είναι μπλοκαρισμένη, η διεργασία πρέπει να μετακινείται σε χωριστή ουρά διεργασιών, ανάλογα με τον αισθητήρα απ’ όπου περιμένει να φτάσουν δεδομένα.

Η συμπληρωματική διαδικασία, η διαδικασία αφύπνισης, γίνεται όταν κάποιος αισθητήρας αποστείλει μετρήσεις. Αφού ανανεωθούν οι σχετικές τιμές στους sensor buffers, το τμήμα συλλογής δεδομένων του Lunix:TNG ξυπνά όσες διεργασίες κοιμόντουσαν περιμένοντας τα αποτελέσματα.

Ο κώδικας του πυρήνα ορίζει τον τύπο wait_queue_head_t για να περιγράψει μια ουρά αναμονής διεργασιών. Για κάθε αισθητήρα χρησιμοποιείται μια τέτοια ουρά. Όταν η read() διαπιστώσει ότι δεν υπάρχουν νέα δεδομένα και η διαδικασία πρέπει να κοιμηθεί, χρησιμοποιεί την κλήση wait_event_interruptible() ώστε η τρέχουσα διεργασία να μπλοκάρει στην ανάλογη ουρά.

### Κρίσιμα τμήματα στο χώρο πυρήνα

Συχνά υπάρχουν τμήματα κώδικα (κρίσιμα τμήματα) τα οποία χρειάζεται να εκτελούνται αδιαίρετα και μόνο σε έναν επεξεργαστή, γιατί έχουν πρόσβαση σε μοιραζόμενα δεδομένα.

Οι δύο σημαντικότεροι μηχανισμοί που προσφέρει το Linux για την υλοποίηση κρίσιμων τμημάτων είναι οι σηματοφορείς (semaphores) και τα spinlocks.

Στον κώδικα πυρήνα αναπαρίστανται από τη δομή struct semaphore. Αρχικοποιούνται με χρήση της sema_init(), ενώ η πράξη P, κλείδωμα του σηματοφορέα υλοποιείται από τη συνάρτηση down() και η πράξη V, απελευθέρωση του σηματοφορέα, από τη συνάρτηση up().

Αν ο σηματοφορέας δεν είναι διαθέσιμος κατά την εκτέλεση της down(), η διεργασία εκ μέρους της οποίας εκτελείται ο κώδικας πυρήνα θα μπλοκαριστεί, θα κοιμηθεί, έως ότου εκτελεστεί η πράξη up() σε αυτόν. Αυτό σημαίνει ότι η down() επιτρέπεται μόνο σε process context: η χρήση σηματοφορέων δεν είναι κατάλληλη για να κλειδωθούν δεδομένα για τα οποία ανταγωνίζεται κώδικας που τρέχει σε interrupt context, καθώς στην περίπτωση αυτή δεν υπάρχει διεργασία η οποία θα κοιμηθεί σε ανάλογη ουρά αναμονής. Αντί της down() καλό είναι να χρησιμοποιείτε, αν δεν υπάρχει ιδιαίτερος λόγος, τη συνάρτηση down_interruptible() στον κώδικά σας. Η διαφορά της είναι ότι η διεργασία ξυπνά όχι μόνο αν κάποιος ξεκλειδώσει το σηματοφορέα, αλλά και αν δεχθεί κάποιο σήμα. Έτσι, δεν εμφανίζεται κολλημένη για πάντα και μπορεί να δεχθεί σήματα, πχ. το σήμα SIGINT πατώντας Ctrl-C.

Η λειτουργία των σηματοφορέων βασίζεται στο χρονοδρομολογητή (scheduler) του συστήματος: όταν κάποια διεργασία καλέσει την down() σε κλειδωμένο σηματοφορέα, κοιμάται. Αντίθετα, στην περίπτωση των spinlocks, ένα τμήμα κώδικα που δεν μπορεί να πάρει το κλείδωμα γιατί είναι κατειλημμένο θα προσπαθεί συνεχώς έως ότου τα καταφέρει χωρίς να αφήσει τη CPU (“spins” σε busy-wait loop). Αυτό κάνει τα spinlocks κατάλληλα για χρήση σε interrupt context, όπου για παράδειγμα μια δομή δεδομένων μπορεί να μεταβάλλεται και από κώδικα που τρέχει σε process context και από έναν interrupt handler (π.χ. ο TTY buffer προστατεύεται με spinlock, γιατί γίνεται πρόσβαση σε αυτόν από interrupt context). Οι κύριες συναρτήσεις χειρισμού spinlocks είναι η spin_lock(), spin_unlock(), spin_lock_init().

Στην περίπτωση του υπό κατασκευή οδηγού, οι Lunix sensor buffers προστατεύονται με spinlocks. Αυτό συμβαίνει γιατί η συνάρτηση που τους ανανεώνει τρέχει σε interrupt context, όταν παραληφθούν δεδομένα από τη σειριακή θύρα.

### Κατασκευή του οδηγού

Έχοντας διαβάσει όλα τα παραπάνω, ίσως αναρωτιέστε από ποιο σημείο θα πρέπει να αρχίσετε για την κατασκευή του ζητούμενου οδηγού.

Η ανάπτυξη θα γίνει μέσα σε εικονική μηχανή (utopia), στην οποία θα έχετε δικαιώματα διαχειριστή (root). Η εικονική μηχανή που σας δίνεται έχει πυρήνα Linux 5.10 αλλά ο κώδικας του kernel module που σας δίνεται είναι για έκδοση πυρήνα 6.11. Για αυτό το λόγο θα χρειαστεί να μεταγλωττίσετε και να εγκαταστήσετε στο utopia την έκδοση 6.11 του πυρήνα. Για τη συγγραφή και μεταγλώττιση του κώδικα θα κάνετε login ως απλοί χρήστες και θα έχετε ορισμένα τερματικά ανοιχτά ως root ώστε να μπορείτε να παρακολουθείτε το αρχείο καταγραφής του πυρήνα και να προσθαφαιρείτε το module σας.

Ξεκινήστε από τον κώδικα που σας δίνεται. Ο κώδικας που χρειάζεται να προσθέσετε εντάσσεται στα αρχεία lunix-chrdev.h και lunix-chrdev.c, τα οποία περιέχουν ήδη ένα σύντομο σκελετό. Υπάρχουν σχόλια σε σημεία που πρέπει να κάνετε αλλαγές ή να προσθέσετε κώδικα, ενώ πολύ χρήσιμη θα βρείτε την υλοποίηση του scull και των παραλλαγών του.

Οπότε, διαβάζετε τμήματα του υπάρχοντα κώδικα, ξεκινάτε να προσθέτετε τον δικό σας και μεταγλωττίζετε με χρήση της εντολής make και του παρεχόμενου Μakefile.

Με την εντολή dmesg μπορείτε να δείτε τα τελευταία μηνύματα του πυρήνα (πολύ χρήσιμη για debugging με διάσπαρτες κλήσεις printk() / debug() για να μπορείτε να παρακολουθείτε πώς τρέχει ο κώδικάς σας). Για να παρακολουθείτε το αντίστοιχο αρχείο καταγραφής των μηνυμάτων του πυρήνα καθώς προστίθενται νέες εγγραφές σε αυτό, τρέξτε less /var/log/kern.log και πιέστε Shift-f.

### Λειτουργία του οδηγού σε περιβάλλον QEMU-KVM

Το παράδειγμα παραπάνω αναφέρεται σε χρήση του οδηγού σε φυσικό σύστημα, όπου ο σταθμός βάσης εμφανίζεται συνδεδεμένος σε συσκευή Serial-over-USB, /dev/ttyUSB1. Για τις ανάγκες του εργαστηρίου, η ανάπτυξη γίνεται σε περιβάλλον εικονικής μηχανής QEMU-KVM. Στην περίπτωση αυτή, αν είστε σε μηχάνημα του εργαστηρίου και έχετε πρόσβαση σε πραγματικό αισθητήρα, χρειάζεται να απεικονιστεί η θύρα /dev/ttyUSB1 στη δεύτερη εικονική σειριακή θύρα του QEMU. Οπότε, το παράδειγμα ισχύει όπως είναι, ο οδηγός συσκευής δεν μπορεί να καταλάβει ότι εκτελείται μέσα σε εικονική μηχανή, αρκεί να χρησιμοποιηθεί η /dev/ttyS1 αντί της /dev/ttyUSB1.

Η απεικόνιση της /dev/ttyUSB1 του host στη δεύτερη σειριακή του VM γίνεται με
χρήση της παραμέτρου:

```bash
-chardev tty,id=sensors0,path=/dev/ttyUSB1
```

στη γραμμή εντολών του script που εκτελεί το QEMU-KVM. Από τη στιγμή αυτή, κάθε πρόσβαση στην εικονική σειριακή /dev/ttyS1 οδηγεί σε πρόσβαση στη θύρα /dev/ttyUSB1.

### Χρήση σε μηχάνημα εκτός εργαστηρίου

Μέρος της ανάπτυξης του οδηγού πιθανότατα θα γίνει σε μηχανήματα εκτός εργαστηρίου, όπου δεν υπάρχει διαθέσιμος αισθητήρας, συνδεδεμένος στη θύρα /dev/ttyUSB1. Παράδειγμα τέτοιου μηχανήματος είναι εικονική μηχανή QEMU-KVM σε προσωπικό σας μηχάνημα, ή στο cloud ~okeanos.

Προς διευκόλυνσή σας, έχει εγκατασταθεί στο μηχάνημα [lunix.cslab.ece.ntua.gr](http://lunix.cslab.ece.ntua.gr/) εξυπηρετητής TCP/IP, ο οποίος εκπέμπει συνεχώς μετρήσεις από σταθμό βάσης μόνιμα συνδεδεμένο στο συγκεκριμένο σύστημα. Ο εξυπηρετητής είναι προσβάσιμος στην θύρα TCP 49152. Οπότε, στην πλευρά του πελάτη χρειάζεται να συνδέσετε, μέσω δικτύου, την εικονική σειριακή θύρα του QEMU με τον εξυπηρετητή που εκπέμπει πακέτα δεδομένων από το δίκτυο αισθητήρων. Το script [utopia.sh](http://utopia.sh/) που σας δίνεται, ανακατευθύνει αυτόματα τη δεύτερη σειριακή θύρα του εικονικού μηχανήματος (/dev/ttyS1) στη θύρα TCP [lunix.cslab.ece.ntua.gr:49152](http://lunix.cslab.ece.ntua.gr:49152/), χωρίς να απαιτείται κάποια άλλη ενέργεια από εσάς. Δείτε τις παραμέτρους - chardev, -device στην εντολή που ξεκινά τη διεργασία του QEMU.
